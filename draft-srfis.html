<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link href="admin.css" rel="stylesheet" type="text/css">
    <link href="list.css" rel="stylesheet" type="text/css">
    <link href="favicon.png" rel="icon" sizes="192x192" type="image/png">
    <meta name=viewport content="width=device-width, initial-scale=1" />
    <title>Draft Scheme Requests for Implementation</title>
  </head>
  <body>
    <h1>Draft Scheme Requests for Implementation</h1>
    <div id="srfis">
      <input class="search" placeholder="Search" tabindex="1" />
      Sort by
      <button class="sort" data-sort="authors" tabindex="2" >authors</button>
      <button class="sort" data-sort="date" tabindex="3" >date</button>
      <button class="sort" data-sort="name" tabindex="4" >name</button>
      <button class="sort" data-sort="number" tabindex="5" >number</button>
      <ul class="list">
      <li class="card draft"><a class="card-anchor" href="srfi-146/"></a><span class="number">146</span><span class="name">Mappings</span><span class="authors">by Marc Nieper-Wißkirchen</span><span class="date-group">Draft: <span class="date">2016/12/18</span></span><span class="status" data-status="draft"></span><div class="abstract">      <p><em>Mappings</em> are finite sets of
      associations, where each association is a pair consisting of a key and an
      arbitrary Scheme value. The keys are elements of a suitable domain. Each
      mapping holds no more than one association with the same key. The
      fundamental mapping operation is retrieving the value of an association
      stored in the mapping when the key is given.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-150/"></a><span class="number">150</span><span class="name">Hygienic ERR5RS Record Syntax (reduced)</span><span class="authors">by Marc Nieper-Wißkirchen</span><span class="date-group">Draft: <span class="date">2017/1/2</span></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-131/">SRFI 131: ERR5RS Record Syntax (reduced)</a>.</span><div class="abstract">	<p>
	  This SRFI provides a specification and portable implementation of an
	  extension of the ERR5RS record syntax
	  of <a href="http://srfi.schemers.org/srfi-131/srfi-131.html">SRFI
	  131</a>, where field names inserted by macro transformers are
	  effectively renamed as if the macro transformer inserted a binding.
	  This makes this SRFI compatible with the semantics of the record-type
	  definitions of
	  the <a href="http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs.pdf">R7RS</a>
	  as intended by
	  its <a href="https://groups.google.com/d/msg/scheme-reports-wg2/oKuhgwaM45w/KXgPrh8oAwAJ">authors</a>.
	  In addition, field names may also be other types of Scheme datums,
	  like numbers and strings, or
	  <a href="https://srfi.schemers.org/srfi-88/srfi-88.html">SRFI 88</a> keyword objects.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-152/"></a><span class="number">152</span><span class="name">String Library (reduced)</span><span class="authors">by John Cowan</span><span class="date-group">Draft: <span class="date">2017/6/3</span></span><span class="status" data-status="draft"></span><div class="abstract">      <p>Scheme has an impoverished set of
      string-processing utilities, which is a problem for authors of portable
      code. This SRFI proposes a coherent and comprehensive set of
      string-processing procedures. It is a reduced version of SRFI 13 that has
      been aligned with SRFI 135, Immutable Texts. Unlike SRFI 13, it has been
      made consistent with the R5RS, R6RS, and R7RS-small string
      procedures.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-153/"></a><span class="number">153</span><span class="name">Ordered Sets and Bags</span><span class="authors">by John Cowan</span><span class="date-group">Draft: <span class="date">2017/6/28</span></span><span class="status" data-status="draft"></span><div class="abstract">      <p><em>Isets</em> and <em>ibags</em> (also known
      as multisets) are immutable collections that can contain any Scheme
      object. Isets enforce the constraint that no two elements can be the same
      in the sense of the iset's associated <em>equality predicate</em>; ibags
      do not. The elements in an iset or ibag appear in a fixed order
      determined by the comparator used to create it.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-154/"></a><span class="number">154</span><span class="name">First-class dynamic extents</span><span class="authors">by Marc Nieper-Wißkirchen</span><span class="date-group">Draft: <span class="date">2017/7/3</span></span><span class="status" data-status="draft"></span><div class="abstract">	<p>Scheme has the notion of the <em>dynamic extent</em> of a
	procedure call.  A number of standard Scheme procedures and
	syntaxes
	like <code>dynamic-wind</code>, <code>call-with-current-continuation</code>,
	and <code>parameterize</code>
	deal with the dynamic extent indirectly.

	<p>This SRFI reifies the dynamic extent into a first-class value
	together with a well-defined procedural interface and a syntax to
	create procedures that remember not only their environment at
	creation time but also their dynamic extent, which includes their
	dynamic environment.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-155/"></a><span class="number">155</span><span class="name">Promises</span><span class="authors">by Marc Nieper-Wißkirchen</span><span class="date-group">Draft: <span class="date">2017/7/4</span></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-45/">SRFI 45: Primitives for Expressing Iterative Lazy Algorithms</a>.</span><div class="abstract">	<p>
	  Scheme, like ML, is a programming language with strict evaluation
	  while others, like Haskell, use lazy evaluation.  Scheme, however,
	  possesses the primitives <code>delay</code> and <code>force</code>
	  that make it possible to express lazy algorithms in the Scheme
	  programming language.

	<p>
	  Lazy evaluation does not go well in conjunction with imperative,
	  non-functional, side effecting code.  It should, however, be
	  applicable in a purely functional setting.  This is the case for the
	  delayed evaluation model as described in the R7RS as long as no
	  dynamically bound variables, also known as parameter objects, are
	  present.  It is the purpose of this SRFI to rework the specification
	  in the R7RS so that lazy evaluation works with purely functional code
	  that makes use of dynamic environments or, more generally, the dynamic
	  extent.  This is done by remembering the dynamic extent in effect when
	  the <code>delay</code> expression is evaluated.

	<p>
	  Another perceived misfeature of the R7RS model of delayed evaluation
	  is the apparent need of the <code>delay-force</code> special form to
	  express iterative lazy algorithms.  It is shown that
	  the <code>delay-force</code> special form is unneeded and that the
	  implementation can (and should) handle iterative lazy algorithms
	  without space leaks.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-156/"></a><span class="number">156</span><span class="name">Syntactic combiners for binary predicates</span><span class="authors">by Panicz Maciej Godek</span><span class="date-group">Draft: <span class="date">2017/7/10</span></span><span class="status" data-status="draft"></span><div class="abstract"><p>Recognizing binary predicates as a specific area
  in which the use of prefix operators is an impediment,
  we propose a thin layer of "syntactic stevia" for in-fixing
  such predicates. It can be implemented using regular Scheme
  macros. We suggest that the code <code>(is x &lt; y)</code> should
  be transformed to <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code>
  -- to <code>(let ((y* y)) (and (&lt; x y*) (&lt;= y* z)))</code>.
  In addition, we suggest special meaning to the <code>_</code> symbol:
  <code>(is _ &lt; y)</code> and <code>(is x &lt; _)</code>
  should be transformed to <code>(lambda (_) (&lt; _ y))</code>
  and <code>(lambda (_) (&lt; x _))</code>, respectively.
  This SRFI document also describes some other uses of the
  <code>is</code> macro and its limitations.</p></div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-157/"></a><span class="number">157</span><span class="name">Continuation marks</span><span class="authors">by Marc Nieper-Wißkirchen</span><span class="date-group">Draft: <span class="date">2017/7/17</span></span><span class="status" data-status="draft"></span><div class="abstract"><p>
  Continuation marks are a programming language feature that
  allows one to attach information to and retrieve information from
  continuations, generalizing stack inspection.  Conceptually, a
  continuation consists of a number of frames where each frame
  stands for an active procedure call that is not a tail call.  At
  most one mark for a given key can be attached to a single frame.
<p>
  Besides stack inspection, continuation marks can be used to
  implement dynamic scope, delimited continuations, or delayed
  evaluation that is able to handle iterative lazy algorithms.

  This SRFI proposes to add continuation marks to the Scheme
  programming language.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-158/"></a><span class="number">158</span><span class="name">Generators and Accumulators</span><span class="authors">by Shiro Kawai, John Cowan, Thomas Gilray</span><span class="date-group">Draft: <span class="date">2017/8/12</span></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-121/">SRFI 121: Generators</a>.</span><div class="abstract"><p>This SRFI defines utility procedures that create, transform, and consume generators.
  A generator is simply a procedure with no arguments that works
  as a source of values.  Every time it is called,
  it yields a value.  Generators may be finite or infinite; a finite
  generator returns an end-of-file object to indicate that it is exhausted.
  For example, <code>read-char</code>, <code>read-line</code>,
  and <code>read</code> are generators that
  generate characters, lines, and objects from the current input port.
  Generators provide lightweight laziness.
</p>

<p>This SRFI also defines procedures that return accumulators.
  An accumulator is the inverse of a generator:  it is a procedure of one argument
  that works as a sink of values.
</p></div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-159/"></a><span class="number">159</span><span class="name">Combinator Formatting</span><span class="authors">by Alex Shinn</span><span class="date-group">Draft: <span class="date">2017/8/21</span></span><span class="status" data-status="draft"></span><div class="abstract"><p>A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p></div></li></ul></div>
    <script crossorigin="anonymous"
	    integrity="sha384-JDmRxRiXkNkskRM5AD4qHRGk9ItwZ9flbqOpsRYs8SOrIRwcMtTGKP2Scnjptzgm"
	    src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"
	    type="application/javascript"></script>
    <script src="list.js" type="application/javascript"></script></body></html>
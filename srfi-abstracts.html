<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI Abstracts</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
     });</script>
    <script crossorigin="anonymous"
	    integrity="sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv"
	    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
	    type="text/javascript"></script>
  </head>

  <body>

<h1><a href="/">SRFI</a> Abstracts</h1>

<p>These are the abstracts from all SRFIs, collected on one page for easy reference.</p>

<h2><a href="srfi-0/">SRFI 0</a>: Feature-based conditional expansion construct</h2>

<p>
It is desirable that programs which depend on additions to standard
Scheme name those additions.  SRFIs provide the specifications of
these additions ("features"), and SRFI 0 provides the means to
actually check that these features are present in the Scheme system by
means of the <code>cond-expand</code> construct.  It is anticipated
that there will be two main classes of features:
</p>

<p>
<ul>
<li>sets of value and syntax bindings</li>
<li>reader syntax extensions</li>
</ul>
</p>

<p>
("Reader syntax" refers to aspects of the syntax described by the
grammars in the Scheme reports.)
</p>

<p>
The former class of features will probably include most SRFIs,
exemplified by the list library specified in <a href="srfi-1/">SRFI
1</a>.  The latter class includes Unicode source code support and
different kinds of parentheses.
</p>

<p>
Control over the presence of individual features will vary over
different Scheme systems.  A given feature may be absent or
provided by default in some Scheme systems and in others some
mechanism (such as an "import" clause in the code or a program
configuration file, a command line option, a dependency declaration in
a module definition, etc.) will be required for the feature to
be present in the system.
</p>

<p>
Moreover, in some systems a given feature may be in effect
throughout the entire program if it is in effect anywhere at all.  Other
systems may have more precise mechanisms to control the scope of a
feature (this might be the case for example when a module system is
supported).  In general it is thus possible that a feature is
in effect in some parts of the program and not in others.  This
allows conflicting SRFIs to be present in a given program as long
as their scope do not intersect.
</p>

<p>
SRFI 0 does not prescribe a particular mechanism for controlling the
presence of a feature as it is our opinion that this should be the
role of a module system.  We expect that future module system SRFIs
will need to extend the semantics of SRFI 0 for their purposes, for
example by defining feature scoping rules or by generalizing the
feature testing construct.
</p>

<h2><a href="srfi-1/">SRFI 1</a>: List Library</h2>

<p>
<abbr title="Revised^5 Report on Scheme">R5RS</abbr> Scheme has an impoverished set of list-processing utilities, which is a
problem for authors of portable code.  This <abbr title="Scheme Request for Implementation">SRFI</abbr> proposes a coherent and
comprehensive set of list-processing procedures; it is accompanied by a
reference implementation of the spec. The reference implementation is
<ul>
<li>portable
<li>efficient
<li>completely open, public-domain source
</ul>

<!--========================================================================-->

<h2><a href="srfi-2/">SRFI 2</a>: AND-LET*: an AND with local bindings, a guarded LET* special form</h2>

<P>Like an ordinary AND, an AND-LET* special form evaluates its arguments --
expressions -- one after another in order, till the first one that
yields #f. Unlike AND, however, a non-#f result of one expression can
be bound to a fresh variable and used in the subsequent expressions.
AND-LET* is a cross-breed between LET* and AND.

<h2><a href="srfi-3/">SRFI 3</a>: List-Set Library</h2>

<p>
This SRFI proposes a coherent and comprehensive set of procedures for
manipulating lists as sets; it is accompanied by a reference implementation
of the spec. The reference implementation is
</p>

	<ul>
	  <li>portable</li>
	  <li>efficient</li>
	  <li>completely open, public-domain source</li>
	</ul>


<p>
Be aware that these procedures are inherently O(n^2) in the lengths of
their parameter lists - serious set operations on large lists should use
alternate techniques.</p>

<h2><a href="srfi-4/">SRFI 4</a>: Homogeneous numeric vector datatypes</h2>

This SRFI describes a set of datatypes for vectors whose elements are
of the same numeric type (signed or unsigned exact integer or inexact
real of a given precision).  These datatypes support operations
analogous to the Scheme vector type, but they are distinct datatypes.
An external representation is specified which must be supported by the
<code>read</code> and <code>write</code> procedures and by the program
parser (i.e. programs can contain references to literal homogeneous
vectors).

<h2><a href="srfi-5/">SRFI 5</a>: A compatible let form with signatures and rest arguments</h2>

The <i>named-let</i> incarnation of the <code>let</code> form has two slight
inconsistencies with the <code>define</code> form.  As defined, the <code>let</code>
form makes no accommodation for rest arguments, an issue of functionality
and consistency.  As defined, the <code>let</code> form does not accommodate
signature-style syntax, an issue of aesthetics and consistency.  Both
issues are addressed here in a manner which is compatible with the traditional
<code>let</code> form but for minor extensions.

<h2><a href="srfi-6/">SRFI 6</a>: Basic String Ports</h2>

Scheme's i/o primitives are extended by adding three new procedures
that
<ul>
<li>create an input port from a string,
<li>create an output port whose contents are accumulated in Scheme's
    working memory instead of an external file, and
<li>extract the accumulated contents of an in-memory output port
    and return them in the form of a string.
</ul>

<h2><a href="srfi-7/">SRFI 7</a>: Feature-based program configuration language</h2>

<p>
This SRFI describes a configuration language to be used for specifing
the set of Scheme features or extensions required to run a program.
In addition to a list of required features, a program may also contain
Scheme code to be used only when a particular feature or combination of
features is available.
</p>

<p>
The configuration language is entirely distinct from Scheme; it is
neither embedded in Scheme nor includes Scheme as a subset.
</p>

<h2><a href="srfi-8/">SRFI 8</a>: receive: Binding to multiple values</h2>

<p>
The only mechanism that R<sup>5</sup>RS provides for binding identifiers to
the values of a multiple-valued expression is the primitive
<code>call-with-values</code>.  This SRFI proposes a more concise, more
readable syntax for creating such bindings.
</p>

<h2><a href="srfi-9/">SRFI 9</a>: Defining Record Types</h2>

This SRFI describes syntax for creating new data types, called record types.
A predicate, constructor, and field accessors and modifiers are defined for
each record type.  Each new record type is distinct from all existing types,
including other record types and Scheme's predefined types.

<h2><a href="srfi-10/">SRFI 10</a>: #, external form</h2>

<P>The present SRFI proposes an extensible external representation of
Scheme values, a notational convention for future SRFIs. This SRFI
adds <CODE>#,(</CODE> as a new token and extends production rules of
the grammar for a Scheme reader. The <CODE>#,()</CODE> form can be
used for example to denote values that do not have a convenient
printed representation, as well for conditional code compilation. It
is proposed that future SRFIs that contain new read syntax for values
use the <CODE>#,()</CODE> notation with an appropriate tag symbol.
<P>As a particular example and the reference implementation for the
<CODE>#,()</CODE> convention, this SRFI describes an interpretation of
the <CODE>#,()</CODE> external form as a read-time application.

<h2><a href="srfi-11/">SRFI 11</a>: Syntax for receiving multiple values</h2>

The SRFI introduces syntactic forms LET-VALUES and LET*-VALUES that bind the values of
expressions that return multiple values.

<h2><a href="srfi-12/">SRFI 12</a>: Exception Handling</h2>

The SRFI defines exception-handling constructs for Scheme, including
<UL>

 <LI> the CURRENT-EXCEPTION-HANDLER procedure for obtaining the
 current exception-handling procedure,

 <LI> the WITH-EXCEPTION-HANDLER procedure and HANDLE-EXCEPTIONS form
 for installing an exception-handling procedure,

 <LI> the ABORT and SIGNAL procedures for raising exceptions, and

 <LI> constructs for creating and inspecting <EM>condition</EM>
 values, which encapsulate information about an exception.

</UL>

<P>

This SRFI requires a Scheme implementation to raise an exception
whenever an error is to be signaled or whenever the system determines
that evaluation cannot proceed in a manner consistent with the
semantics of Scheme. However, this SRFI does not define the
information to be supplied by an implementation for each possible kind
of exception; such a specification is left open for future SRFIs.

<h2><a href="srfi-13/">SRFI 13</a>: String Libraries</h2>

<p>

<abbr title="Revised^5 Report on Scheme">R5RS</abbr>
Scheme has an impoverished set of string-processing utilities, which is a
problem for authors of portable code. This <abbr title="Scheme Request for
Implementation">SRFI</abbr> proposes a coherent and comprehensive set of
string-processing procedures; it is accompanied by a reference implementation
of the spec. The reference implementation is
<ul>
<li>portable
<li>efficient
<li>open source
</ul>
<p>
The routines in this SRFI are backwards-compatible with the string-processing
routines of
<abbr title="Revised^5 Report on Scheme">R5RS</abbr>.

<!--========================================================================-->

<h2><a href="srfi-14/">SRFI 14</a>: Character-set Library</h2>

<p>

The ability to efficiently represent and manipulate sets of characters is an
unglamorous but very useful capability for text-processing code -- one that
tends to pop up in the definitions of other libraries.  Hence it is useful to
specify a general substrate for this functionality early.  This SRFI defines a
general library that provides this functionality.

It is accompanied by a reference implementation for the spec. The reference
implementation is fairly efficient, straightforwardly portable, and has a
"free software" copyright. The implementation is tuned for "small" 7 or 8
bit character types, such as ASCII or Latin-1; the data structures and
algorithms would have to be altered for larger 16 or 32 bit character types
such as Unicode -- however, the specs have been carefully designed with these
larger character types in mind.

Several forthcoming SRFIs can be defined in terms of this one:
<ul>
    <li> string library
    <li> delimited input procedures (<em>e.g.</em>, <code>read-line</code>)
    <li> regular expressions
</ul>


<!--========================================================================-->

<h2><a href="srfi-15/">SRFI 15</a>: Syntax for dynamic scoping</h2>

FLUID-LET, a binding syntax for dynamic scoping, is introduced.

<h2><a href="srfi-16/">SRFI 16</a>: Syntax for procedures of variable arity</h2>

CASE-LAMBDA, a syntax for procedures with a variable number of arguments,
is introduced.

<h2><a href="srfi-17/">SRFI 17</a>: Generalized set!</h2>

This is a proposal to allow procedure calls that evaluate
to the "value of a location" to be used to <em>set</em>
the value of the location, when used as the first
operand of <code>set!</code>.
For example:
<pre>
(set! (car x) (car y))
</pre>
becomes equivalent to
<pre>
(set-car! x (car y))
</pre>

<p>
      Many programming languages have the concept of an <i>lvalue</i>.
that is an "expression" that "evaluates" to a location, and
which can appear on the left-hand-side of an assignment.
Common Lisp has a related concept of "generalized variables"
which can be used in <code>setf</code> and some other special forms.
However, the Common Lisp concept is based on the idea of
compile-time recognition of special "location-producing" functions;
this does not seem to be in the "spirit of Scheme".
<p>
This SRFI proposes an extension of <code>set!</code>
so that it provides similar functionality as Common Lisp's <code>setf</code>,
except that the updater is associated with a procedure value,
rather than a name.

<h2><a href="srfi-18/">SRFI 18</a>: Multithreading support</h2>

<P>
This SRFI
defines the following multithreading datatypes for Scheme
<UL>
<LI>Thread
<LI>Mutex
<LI>Condition variable
<LI>Time
</UL>
</P>

<P>
It also defines a mechanism to handle exceptions and some
multithreading exception datatypes.
</P>

<h2><a href="srfi-19/">SRFI 19</a>: Time Data Types and Procedures</h2>

Points in time are represented a the number of seconds (with
nanosecond precision) since "the epoch," a zero point in time. Several
standard variants are defined, including UTC (universal coordinated
time), TAI (international atomic time), and monotonic time. A point in time can also be
represented as a Julian Day or Modified Julian Day number. Time
durations, including time spent in a process or thread, are defined. Conversion
routines are provided. The procedure CURRENT-TIME queries the current
time in a specified variant, with a system-dependent
resolution. Procedures for time arithmetic and time comparisons are
also provided.

<p>A date is a representation of a point in time in the Gregorian
calendar, a 24 hour clock (with nanosecond precision) and a
time zone offset from UTC. Procedures for
converting between time and dates are provided, as well as for reading
and writing string representations of dates.

<h2><a href="srfi-20/">SRFI 20</a>: Simple object system</h2>

This SRFI presents an object system to define classes, generic functions
as well as to support some level of introspection. This object system
is based on Meroon-V3 which is itself inspired by CLOS. <a
href="http://www-spi.lip6.fr/~queinnec/WWW/Meroon.html"> Meroon-V3</a>
is distributed and used since 1992.

<h2><a href="srfi-21/">SRFI 21</a>: Real-time multithreading support</h2>

<P>
This SRFI
defines the following multithreading datatypes for Scheme
<UL>
<LI>Thread
<LI>Mutex
<LI>Condition variable
<LI>Time
</UL>
</P>

<P>
It also defines a mechanism to handle exceptions and some
multithreading exception datatypes.
</P>

<h2><a href="srfi-22/">SRFI 22</a>: Running Scheme Scripts on Unix</h2>

<p>This SRFI describes basic prerequisites for running Scheme programs
as Unix scripts in a uniform way.  Specifically, it describes:</p><ul><li>the syntax of Unix scripts written in Scheme,</li><li>a uniform convention for calling the Scheme script
     interpreter, and</li><li>a method for accessing the Unix command line arguments from
     within the Scheme script.</li></ul>

<h2><a href="srfi-23/">SRFI 23</a>: Error reporting mechanism</h2>

A mechanism is proposed to allow Scheme code to report errors and abort
execution.
The proposed mechanism is already implemented in several Scheme systems
and can be implemented, albeit imperfectly, in any R5RS conforming Scheme.

<h2><a href="srfi-24/">SRFI 24</a>: Define-syntax in local lexical scopes</h2>

<p>This document specifies a proper extension to Scheme which allows
<b>define-syntax</b> forms to appear in those places where local
definitions can appear (R5RS, 5.2.2). A corresponding letrec-variant
is described.

<h2><a href="srfi-25/">SRFI 25</a>: Multi-dimensional Array Primitives</h2>

<p>
A core set of procedures for creating and manipulating heterogeneous
multidimensional arrays is proposed. The design is consistent with the
rest of Scheme and independent of other container data types. It
provides easy sharing of parts of an array as other arrays without
copying, encouraging a declarative style of programming.
</p>

<p>
The specification is based on an original contribution by Alan Bawden
in 1993.
</p>

<h2><a href="srfi-26/">SRFI 26</a>: Notation for Specializing Parameters without Currying</h2>

When programming in functional style,
it is frequently necessary to specialize some of the
parameters of a multi-parameter procedure.
For example, from the binary operation <code>cons</code>
one might want to obtain the unary operation
<code>(lambda (x) (cons 1 x))</code>.
This specialization of parameters is also known as
"partial application", "operator section" or "projection".<p>

The mechanism proposed here allows to write this sort
of specialization in a simple and compact way.
The mechanism is best explained by a few examples:<p>

<TABLE>
<TR>
<TD><code>(cut cons (+ a 1) &lt;&gt;)</code>
<TD>is the same as
<TD><code>(lambda (x2) (cons (+ a 1) x2))</code>
</TR>
<TR>
<TD><code>(cut list 1 &lt;&gt; 3 &lt;&gt; 5)</code>
<TD>is the same as
<TD><code>(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
</TR>
<TR>
<TD><code>(cut list)</code>
<TD>is the same as
<TD><code>(lambda () (list))</code>
</TR>
<TR>
<TD><code>(cut list 1 &lt;&gt; 3 &lt;...&gt;)</code>
<TD>is the same as
<TD><code>(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
</TR>
<TR>
<TD><code>(cut &lt;&gt; a b)</code>
<TD>is the same as
<TD><code>(lambda (f) (f a b))</code>
</TR>
</TABLE><p>

As you see, the macro <code>cut</code> specializes some of the
parameters of its first argument.
The parameters that are to show up as formal
variables of the result are indicated by the symbol <code>&lt;&gt;</code>,
pronouced as "slot". In addition, the symbol <code>&lt;...&gt;</code>,
pronounced as "rest-slot", matches all residual arguments of a variable
argument procedure.
As you can see from the last example above, the first argument can also
be a slot, as one should expect in Scheme.<p>

In addition to <code>cut</code>, there is a variant called <code>cute</code>
(a mnemonic for "<code>cut</code> with evaluated non-slots") which evaluates
the non-slot expressions at the time the procedure is specialized, not at
the time the specialized procedure is called.
For example,<p>

<TABLE>
<TR>
<TD><code>(cute cons (+ a 1) &lt;&gt;)</code>
<TD>is the same as
<TD><code>(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))</code>
</TR>
</TABLE><p>

As you see from comparing this example with the first example above,
the <code>cute</code>-variant will evaluate <code>(+ a 1)</code>
once, while the <code>cut</code>-variant will evaluate it during
every invokation of the resulting procedure.<p>

The mechanism proposed in this SRFI allows specializing any subset
of the variables of a procedure.
The result can be of fixed arity or of variable arity.
The mechanism does not allow permutation, omission, duplication
or any other processing of the arguments;
for this it is necessary to write to use a different
mechanism such as <code>lambda</code>.

<h2><a href="srfi-27/">SRFI 27</a>: Sources of Random Bits</h2>

This document specifies an interface to sources of random bits,
or "random sources" for brevity.
In particular, there are three different ways to use the interface,
with varying demands on the quality of the source and the
amout of control over the production process:

<UL>
<LI>
The "no fuss" interface specifies that
<code>(random-integer </code><I>n</I><code>)</code>
produces the next random integer in {0, ..., <I>n</I>-1} and
<code>(random-real)</code> produces the next random
real number between zero and one.
The details of how these random values are produced may not be
very relevant, as long as they appear to be sufficiently random.
<LI>
For simulation purposes, on the contrary, it is usually necessary
to know that the numbers are produced deterministically by a pseudo
random number generator of high quality and to have explicit access
to its state.
In addition, one might want to use several independent sources of
random numbers at the same time and it can be useful to have some
simple form of randomization.
<LI>
For security applications a serious form of true randomization
is essential, in the sense that it is difficult for an adversary to
exploit or introduce imperfections into the distribution of random bits.
Moreover, the linear complexity of the stream of random bits is more
important than its statistical properties.
In these applications, an entropy source (producing truely random
bits at a low rate) is used to randomize a pseudo random number
generator to increase the rate of available bits.
</UL>
<p>

Once random sources provide the infrastructure to obtain
random bits, these can be used to construct other random deviates.
Most important are floating point numbers of various distributions
and random discrete structures, such as permutations or graphs.
As there is an essentially unlimited number of such objects (with
limited use elsewhere), we do not include them in this SRFI.
In other words, this SRFI is <em>not</em> about making
all sorts of random objects---it is about obtaining random
bits in a portable, flexible, reliable, and efficient way.

<h2><a href="srfi-28/">SRFI 28</a>: Basic Format Strings </h2>

This document specifies Format Strings, a method of
    interpreting a Scheme string which contains a number of escape
    sequences that are replaced with other string data according to
    the semantics of each sequence.

<h2><a href="srfi-29/">SRFI 29</a>: Localization </h2>

This document specifies an interface to retrieving and
    displaying locale sensitive messages. A Scheme program can
    register one or more translations of templated messages, and
    then write Scheme code that can transparently retrieve the
    appropriate message for the locale under which the Scheme
    system is running. <br>

<h2><a href="srfi-30/">SRFI 30</a>: Nested Multi-line Comments</h2>

<p>This SRFI extends R5RS by possibly nested, multi-line
    comments. Multi-line comments start with <code>#|</code> and end
    with <code>|#</code>.</p>

<h2><a href="srfi-31/">SRFI 31</a>: A special form `rec' for recursive evaluation</h2>

We propose the implementation of a special form
called <CODE>rec</CODE>.  This form is a generalization and
combination of the forms <CODE>rec</CODE> and
<CODE>named-lambda</CODE> of [Clinger1985]. It allows the simple and
non-imperative construction of self-referential expressions.  As an
important special case, it extends the A. Church form
<CODE>lambda</CODE> such that it allows the direct definition of
recursive procedures without using further special forms like
<CODE>let</CODE> or <CODE>letrec</CODE>, without using advanced
constructions like the H. B. Curry combinator and, unlike
<CODE>define</CODE>, without introducing variable bindings into the
external environment.

<h2><a href="srfi-32/">SRFI 32</a>: Sort Libraries</h2>

<p>Current Scheme sorting packages are, every one of them,
surprisingly bad. I've designed the API for a full-featured sort
toolkit, which I propose as an SRFI.  The spec comes with 1200 lines
of high-quality reference code: tightly written, highly commented,
portable code, available for free. Implementors want this code. It's
better than what you have.</p>

<h2><a href="srfi-33/">SRFI 33</a>: Integer Bitwise-operation Library</h2>

<p>R5RS Scheme has no utilities for performing bitwise logical operations on
integers or bitstrings, which is a problem for authors of portable code.  This
SRFI proposes a coherent and comprehensive set of these functions; it is
accompanied by a reference implementation of the spec in terms of a set of
seven core operators. The reference implementation is
<ul>
  <li>portable</li>
  <li>efficient</li>
  <li>completely open, public-domain source</li></ul></p>

<p>The precise semantics of these operators is almost never an issue. A
  consistent, portable set of *names* and *parameter conventions*, however, is.
  Hence this SRFI.</p>

<h2><a href="srfi-34/">SRFI 34</a>: Exception Handling for Programs</h2>

This SRFI defines exception-handling and exception-raising constructs for Scheme, including<ul><li>a <code>with-exception-handler</code>
 procedure and a <code>guard</code>
 form for installing exception-handling procedures,</li>
<li>a <code>raise</code>
 procedure for invoking the current exception handler.</li>
</ul>
<p>This SRFI is based on (withdrawn) <a href="srfi-12/">SRFI 12: Exception Handling</a>
by William Clinger, R. Kent Dybvig, Matthew Flatt, and Marc Feeley.</p>

<h2><a href="srfi-35/">SRFI 35</a>: Conditions</h2>

<p>The SRFI defines constructs for creating and inspecting <i>condition</i> types and values.  A condition value encapsulates information about an exceptional situation, or exception. This SRFI also defines a few basic condition types.</p>

<h2><a href="srfi-36/">SRFI 36</a>: I/O Conditions</h2>

<p>This SRFI specifies a set of condition types for I/O errors. The condition types are defined in terms of <a href="srfi-35/">SRFI 35</a>. Moreover, this SRFI requires a Scheme system implementing it to raise exceptions in the sense of <a href="http://srfi.schemers.org/srfi-34/">SRFI 34</a>
 for errors occurring during the execution of the R5RS
 <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.6">I/O operations</a>.</p>

<h2><a href="srfi-37/">SRFI 37</a>: args-fold: a program argument processor</h2>

<p>Many operating systems make the set of argument strings used to invoke a program available (often following the program name string in an array called argv). Most programs need to parse and process these argument strings in one way or another. This SRFI describes a set of procedures that support processing program arguments according to POSIX and GNU C Library Reference Manual guidelines.</p>

<h2><a href="srfi-38/">SRFI 38</a>: External Representation for Data With Shared Structure</h2>

<P>
This SRFI proposes <tt>(write-with-shared-structure)</tt> and
<tt>(read-with-shared-structure)</tt>, procedures for writing
and reading external representations of data containing shared
structure.  These procedures implement a proposed standard
external notation for data containing shared structure.
</P>
<P>
This SRFI permits but does not require replacing the standard
<tt>(write)</tt> and <tt>(read)</tt> functions.  These functions
may be implemented without the overhead in time and space required
to detect and specify shared structure.
</P>
<P>
An implementation conforms to this SRFI if it provides procedures
named <tt>(write-with-shared-structure)</tt> and
<tt>(read-with-shared-structure)</tt>, which produce and read
the same notation as produced by the reference implementation.
It may also provide <tt>(read/ss)</tt> and <tt>(write/ss)</tt>,
equivalent functions with shorter names.
</P>

<h2><a href="srfi-39/">SRFI 39</a>: Parameter objects</h2>

<P>
This SRFI defines <I>parameter</I> objects, the procedure
<CODE>make-parameter</CODE> to
create parameter objects and the <CODE>parameterize</CODE> special
form to dynamically bind parameter objects.  In the dynamic
environment, each parameter object is bound to a cell containing the
value of the parameter.  When a procedure is called the called
procedure inherits the dynamic environment from the caller.  The
<CODE>parameterize</CODE> special form allows the binding of a
parameter object to be changed for the dynamic extent of its body.
</P>

<h2><a href="srfi-40/">SRFI 40</a>: A Library of Streams</h2>

<p>
Along with higher-order functions, one of the hallmarks of functional
programming is lazy evaluation.  A primary manifestation of lazy
evaluation is lazy lists, generally called streams by Scheme
programmers, where evaluation of a list element is delayed until its
value is needed.
</p>

<p>
The literature on lazy evaluation distinguishes two styles of
laziness, called even and odd.  Odd style streams are ubiquitous among
Scheme programs and can be easily encoded with the Scheme primitives
delay and force defined in R5RS.  However, the even style delays
evaluation in a manner closer to that of traditional lazy languages
such as Haskell and avoids an "off by one" error that is symptomatic
of the odd style.
</p>

<p>
This SRFI defines the stream data type in the even style, some
essential procedures and syntax that operate on streams, and motivates
our choice of the even style.  A companion SRFI 41 Stream Library
provides additional procedures and syntax which make for more
convenient processing of streams and shows several examples of their
use.
</p>

<h2><a href="srfi-41/">SRFI 41</a>: Streams</h2>

<p align="justify"><font face="serif">Streams, sometimes
called lazy lists, are a sequential data structure containing elements
computed only on demand.  A stream is either null or is a pair
with a stream in its cdr.  Since elements of a stream are computed
only when accessed, streams can be infinite.  Once computed, the
value of a stream element is cached in case it is needed again.</font></p>

<p align="justify"><font face="serif">Streams without
memoization were first described by Peter Landin in 1965.  Memoization
became accepted as an essential feature of streams about a decade later.
Today, streams are the signature data type of functional programming
languages such as Haskell.</font></p>

<p align="justify"><font face="serif">This Scheme Request for Implementation describes
two libraries for operating on streams: a canonical set of stream primitives
and a set of procedures and syntax derived from those primitives that permits
convenient expression of stream operations. They rely on facilities provided
by R6RS, including libraries, records, and error reporting.  To load both
stream libraries, say:</font></p>

<p align="justify"><font face="monospace">(import (streams))</font></p>

<h2><a href="srfi-42/">SRFI 42</a>: Eager Comprehensions</h2>

This SRFI defines a modular and portable mechanism for
eager comprehensions extending the algorithmic language Scheme
[R5RS].
An eager comprehension is a convenient notation
for one or more nested or parallel loops generating
a sequence of values, and accumulating this sequence into a result.
<h2><a href="srfi-43/">SRFI 43</a>: Vector library</h2>

<p>
  This SRFI proposes a comprehensive and
  complete library of vector operations accompanied by a freely
  available and complete reference implementation.  The reference
  implementation is unencumbered by copyright, and useable with no
  modifications on any Scheme system that is
  R5RS-compliant.  It also provides several
  hooks for implementation-specific optimization as well.
</p>

<p>
  Because this SRFI is more of a library or module specification
  than a request for additions to readers or any other internal
  implementation detail, in an implementation that supports a
  module or structure or package or library or unit (et cetera)
  systems, these procedures should be contained in a module /
  structure / package / library / unit called <tt>vector-lib</tt>.
</p>

<h2><a href="srfi-44/">SRFI 44</a>: Collections</h2>

<p>A Collections API which defines a common naming scheme and set
  of operations for creating, accessing, and manipulating common
  datastructures in Scheme. The API defines accessors, a common
  protocol for value access via generic and specific enumeration,
  and functions for inter-datastructure cooperation. Finally, a concrete
  specification of a compliant set of operators for the standard
  Scheme heterogenous datastructures (lists and vectors) and for
  the homogeneous Scheme string is provided.</p>

<h2><a href="srfi-45/">SRFI 45</a>: Primitives for Expressing Iterative Lazy Algorithms</h2>

Lazy evaluation is traditionally simulated in Scheme using
<code>delay</code> and <code>force</code>.  However, these
primitives are not powerful enough to express
a large class of lazy algorithms that are iterative.
Indeed, it is folklore in the Scheme community that
typical iterative lazy algorithms written using
<code>delay</code> and
<code>force</code> will often
require unbounded memory.

<p>
Although varous modifications of <code>delay</code> and
<code>force</code> had been proposed to resolve this problem (see e.g., the
SRFI-40 discussion list)
they all fail some of the benchmarks provided below.  To our knowledge,
the current SRFI provides the first exhaustive solution to this problem.


<p>
As motivation,
we first explain how the usual laziness encoding using only <code>delay</code>
and <code>force</code> will break the iterative behavior of typical
algorithms that would have been properly tail-recursive
in a true lazy language, causing the computation to require unbounded memory.

<p>
The problem is then resolved by
introducing a set of three operations:
<pre>
    {<code>lazy</code>, <code>delay</code>, <code>force</code>}
</pre>
which allow the programmer to succinctly express lazy algorithms while
retaining bounded space behavior in cases that are properly tail-recursive.
A general
recipe for using these primitives is provided.  An additional procedure
<code>{eager}</code> is provided for the construction of
eager promises in cases where efficiency is a concern.

<p>
Although this SRFI redefines <code>delay</code> and <code>force</code>,
the extension is conservative in the sense that the semantics of the subset {<code>delay</code>, <code>force</code>} in
isolation (i.e., as long as the program does not use <code>lazy</code>)
agrees with that in R5RS.  In other words, no program that uses the
R5RS definitions of delay and force will break if those definition are
replaced by the SRFI-45 definitions of delay and force.

<h2><a href="srfi-46/">SRFI 46</a>: Basic Syntax-rules Extensions</h2>

<p>This SRFI proposes two extensions to the R5RS<sup>1</sup> <code>syntax-rules</code>
pattern language: the first allows <code>syntax-rules</code> macros to generate
macros, where the macro-generated macros use ellipsis that is not used by the
macro-generating macros; the second allows for 'tail patterns.'</p>

<h2><a href="srfi-47/">SRFI 47</a>: Array</h2>

"slib/array.scm"
synthesizes array ideas from Common-Lisp and Alan
Bawden with homogeneous vector ideas from
<A HREF="srfi-4/">SRFI-4</A> and
<A HREF="http://swissnet.ai.mit.edu/~jaffer/SCM">SCM</A>.
The result portably integrates homogeneous and heterogeneous arrays
into Scheme.
<P>

<h2><a href="srfi-48/">SRFI 48</a>: Intermediate Format Strings</h2>

This document specifies Format Strings, a method of interpreting a Scheme string which contains a
number of format directives that are replaced with other string data according to the semantics of each directive.
This SRFI extends <a href="/srfi-28">SRFI-28</a> in being more generally useful but is less general than
advanced format strings in that it does not allow, aside from ~F, for controlled positioning of text within fields.

<h2><a href="srfi-49/">SRFI 49</a>: Indentation-sensitive syntax</h2>

<p>This SRFI descibes a new syntax for Scheme, called I-expressions,
  whith equal descriptive power as S-expressions. The syntax uses
  indentation to group expressions, and has no special cases for
  semantic constructs of the language. It can be used both for program
  and data input.</p>

  <p>It also allows mixing S-expressions and I-expressions freely,
  giving the programmer the ability to layout the code as to maximize
  readability.</p>

<h2><a href="srfi-50/">SRFI 50</a>: Mixing Scheme and C</h2>

<p>This SRFI describes an interface for calling C functions from Scheme, calling Scheme functions from C, and allocating storage in the Scheme heap.  Scheme manages stub functions in C that negotiate between the calling conventions of Scheme and C and the memory allocation policies of both worlds. </p><p>The following facilities are available for interfacing between Scheme and C:</p><ul><li>Scheme code can call C functions.</li><li>The external interface provides full introspection for all Scheme objects.  External code may inspect, modify, and allocate Scheme objects arbitrarily.</li><li>External code may signal errors to the Scheme system.</li><li>External code may call back into Scheme.  Scheme correctly unrolls the process stack on non-local exits.</li><li>External modules may register bindings of names to values with a central registry accessible from Scheme.  Conversely, Scheme code can register shared bindings for access by C code.</li></ul><p>The interface is closely based on that of <a href="http://www.s48.org/">Scheme 48</a> and <a href="http://www.scsh.net/">scsh</a>.</p>

<h2><a href="srfi-51/">SRFI 51</a>: Handling rest list</h2>

<p>
This SRFI introduces the <code>rest-values</code> procedure which has three modes of
operation:
</p>

<ol>
<li>it processes a rest list after checking its elements with default values or
   predicate procedures,</li>

<li> it processes a rest list with default values without checking its elements,</li>

<li> it processes a default list whose elements are lists or pairs, after
   checking their elements that are default values or predicate procedures
   with the elements of a rest list,</li>
</ol>

<p>
and eight macros which additionally check the rest arguments that are returned
by <code>rest-values</code>.
</p>

<h2><a href="srfi-52/">SRFI 52</a>: Permitting and Supporting Extended Character Sets</h2>

<p>This SRFI describes how to modify the <i>Revised Report</i> (<a
href="http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a>) in
order to enable conforming implementations to use an extended
character set such as (but not limited to) <a
href="http://www.unicode.org">Unicode</a>.


<p>Changes to some requirements of the report are recommended.
Currently, the <i>Revised Report</i> contains requirements which are
difficult or impossible to satisfy with some extended character sets.

<p>New required procedures are proposed, specified, and included
in the reference implementation.  These procedures enable portable
Scheme programs to manipulate Scheme source texts and source data
accurately, even in implementations using extended character sets.

<p>This SRFI concludes with some suggestions for implementors
interested in providing good Unicode support, using these suggestions
to illustrate how the proposed changes to the <i>Revised Report</i> can "play
out" in Unicode-based Scheme.

<p>This SRFI does <b>not</b> attempt to provide a comprehensive
library for global text processing.   For example, one issue in global
text processing is the need for linguistically-sensitive,
locale-sensitive procedures for sorting strings.   Such procedures are
beyond the scope of this SRFI.    On the other hand, by making Scheme
compatible with extended character sets, this SRFI is a step in the
direction of permitting global text processing standard libraries to
be developed in a form portable across all conforming implementations.

<p>This SRFI does <b>not</b> propose that implementations be required
to support Unicode or any other extended character set.  It does not
specify a representation for Unicode characters or strings.  It
<b>does</b> revise the specifications of the report so that
<code>char?</code> values <i>may be</i> Unicode (or other) characters.

<p>The reference implementation included should prove to be easily
ported to and effective for all ASCII-only implementations and for
many implementations using an 8-bit character set which is an
extension of ASCII (it will require very minor modifications for each
particular implementation).  Other implementations may need to use a
different implementation.

<h2><a href="srfi-53/">SRFI 53</a>: Syntactic computations with computation-rules</h2>

This SRFI provides a portable framework for
writing complex high-level macros that perform nontrivial
computations during expansion.

<h2><a href="srfi-54/">SRFI 54</a>: Formatting</h2>

<p>This SRFI introduces the CAT procedure that converts any object to a string.
It takes one object as the first argument and accepts a variable number of
optional arguments, unlike the procedure called FORMAT.</p>

<h2><a href="srfi-55/">SRFI 55</a>: require-extension</h2>

<p> This SRFI specifies an extremely simple facility for making an extension
or library available to a Scheme toplevel environment.

<h2><a href="srfi-56/">SRFI 56</a>: Binary I/O</h2>

<p>
  This SRFI extends Scheme with procedures to read and write binary data
  to and from ports, including utility procedures for writing various
  integer and floating point values in both big and little endian
  formats.  Predicates are provided to test if binary I/O is allowed on
  a port, along with new procedures for creating such ports.
<p>

<h2><a href="srfi-57/">SRFI 57</a>: Records</h2>

We describe a syntax for defining record types.
A predicate, constructor,
and field accessors and modifiers may be specified for each record
type.
We also introduce a syntax for declaring record type schemes, representing
families of record types that share a set of field labels.
A polymorphic predicate and
polymorphic field accessors and modifiers may be specified for each
record type scheme.
A syntax is provided for constructing records by
field label, for in-place and for functional record
update, and for composing records.

<h2><a href="srfi-58/">SRFI 58</a>: Array Notation</h2>

<A HREF="srfi-47/">SRFI-47</A>
and its successor
<A HREF="srfi-63/">SRFI-63</A>
provide both homogeneous numeric and heterogeneous multidimensional
arrays which subsume Scheme vectors.  The notation presented here
builds upon Common-Lisp array syntax to represent heterogeneous
arrays; and introduces a new Scheme-based notation for denoting
homogeneous numeric arrays.
<P>

<h2><a href="srfi-59/">SRFI 59</a>: Vicinity</h2>

A vicinity is a descriptor for a place in the file system.  Vicinities
hide from the programmer the concepts of host, volume, directory, and
version.  Vicinities express only the concept of a file environment
where a file name can be resolved to a file in a system independent
manner.
<P>
All of these procedures are file-system dependent.  Use of these
vicinity procedures can make programs file-system
<EM>in</EM>dependent.
<P>

<h2><a href="srfi-60/">SRFI 60</a>: Integers as Bits</h2>

Treating integers as two's-complement strings of bits is an arcane but
important domain of computer science.  It is used for:

<UL>
<LI>hashing;

<LI>Galois-field[2] calculations of error-detecting and
    error-correcting codes;

<LI>cryptography and ciphers;

<LI>pseudo-random number generation;

<LI>register-transfer-level modeling of digital logic designs;

<LI>Fast-Fourier transforms;

<LI>packing and unpacking numbers in persistant data structures;

<LI>space-filling curves with applications to dimension reduction and
    sparse multi-dimensional database indexes; and

<LI>generating approximate seed values for root-finders and
    transcendental function algorithms.

</UL>
<P>

<h2><a href="srfi-61/">SRFI 61</a>: A more general cond clause</h2>

<p>This SRFI proposes an extension to the <code>cond</code> syntax to allow a more
general clause, one that allows binding the results of tests as in the
<code>=&gt;</code> clauses and user-defined meaning of the success &amp; failure of tests.</p>

<h2><a href="srfi-62/">SRFI 62</a>: S-expression comments</h2>

<p>
This SRFI proposes a simple extension to Scheme's lexical syntax that
allows individual S-expressions to be made into comments, ignored by
the reader.  This contrasts with the standard Lisp semicolon commnets,
which make the reader ignore the remainder of the line, and the
slightly less common block comments, as <a
href=""srfi-30/">SRFI 30</a>
defines: both of these mechanisms comment out slices of text, not
S-expressions.
</p>

<h2><a href="srfi-63/">SRFI 63</a>: Homogeneous and Heterogeneous Arrays</h2>

The SRFI, which is to supersede
<A HREF="srfi-47/">SRFI-47</A>,
"Array",

<UL>

<LI>synthesizes array concepts from Common-Lisp and Alan Bawden's
    "array.scm";

</LI><LI>incorporates all the uniform vector types from
    <A HREF="srfi-4/">SFRI-4</A>
    "Homogeneous numeric vector datatypes";

</LI><LI>adds a boolean uniform array type;

</LI><LI>adds 16.bit and 128.bit floating-point uniform-array types;

</LI><LI>adds decimal floating-point uniform-array types; and

</LI><LI>adds array types of (dual) floating-point complex numbers.

</LI></UL>

Multi-dimensional arrays subsume homogeneous vectors as the
one-dimensional case, obviating the need for SRFI-4.
<P>
SRFI-58 gives a read/write invariant syntax for the homogeneous and
heterogeneous arrays described here.
</P><P>

</P>

<h2><a href="srfi-64/">SRFI 64</a>: A Scheme API for test suites</h2>

<p>
This defines an API for writing <dfn>test suites</dfn>, to make it easy
to portably test Scheme APIs, libraries, applications, and implementations.
A test suite is a collection of <dfn>test cases</dfn> that execute
in the context of a <dfn>test-runner</dfn>.  This specifications
also supports writing new test-runners, to allow customization
of reporting and processing the result of running test suites.</p>

<h2><a href="srfi-65/">SRFI 65</a>: define-immutable: A Syntax to Define Identifiers With Immutable Values</h2>

<p>The <tt>define-immutable</tt> form defines an identifier whose
value never changes.</p>

<p>The expression part of the definition is evaluated lazily: it is
not evaluated unless and until the identifier is evaluated.  This
permits an immutable definition to use other definitions in more ways
than is possible when using <tt>define</tt> in internal
definitions.</p>

<p>A series of immutable definitions have simple semantics, making them
easy to program and understand.</p>

<pre>
    (let ()
      (define-immutable x (+ z 5))
      (define-immutable y (/ 100 4))
      (define-immutable z (add-10 y))
      (define-immutable add-10 (add-n 10))
      (define-immutable (add-n n)
        (lambda (x)
          (+ n x)))
      x)
  =>
    40
</pre>

<h2><a href="srfi-66/">SRFI 66</a>: Octet Vectors</h2>

<p>This SRFI defines a set of procedures for creating, accessing, and
  manipulating uniform vectors of octets.</p>

<h2><a href="srfi-67/">SRFI 67</a>: Compare Procedures</h2>

<p>This SRFI can be seen as an extension of the standard procedures
<tt>=</tt>, <tt>&lt;</tt>, <tt>char&lt;?</tt> etc. of
R<sup>5</sup>RS  -- or even as a replacement.
The primary design aspect in this SRFI is the separation of
<em>representing</em> a total order and <em>using it.</em>
For representing the order, we have chosen for truly 3-way
comparisons.
For using it we provide an extensive set of
operations, each of which accepts a procedure used for comparison.
Since these compare procedures are often optional,
comparing built-in types is as convenient as
R<sup>5</sup>RS ,
sometimes more convenient:
For example, testing if the integer index <em>i</em> lies in the
integer range {0, <tt>...</tt>, <em>n</em> <tt>-</tt> 1} can be written as
<tt>(&lt;=/&lt;? 0 i n)</tt>, implicitly invoking <tt>default-compare</tt>.</p>
<p>
As soon as new total orders are required,
the infrastructure provided by this SRFI is far more
convenient and often even more efficient than building
each total order from scratch.</p>
<p>
Moreover, in case Scheme users and implementors find this
mechanism useful and adopt it,
the benefit of having a uniform interface to total orders
to be used in data structures will manifest itself.
Most concretely, a new sorting procedure in the spirit of
this SRFI would have the interface
<tt>(my-sort [ <i>compare</i> ] <i>xs</i>)</tt>,
using <tt>default-compare</tt> if the optional <i>compare</i>
was not provided.
Then <tt>my-sort</tt> could be defined using the entire
infrastructure of this SRFI:
Efficient 2- and 3-way branching,
testing for chains and pairwise inequality,
min/max, and general order statistics.</p>
<p>
</p>

<h2><a href="srfi-68/">SRFI 68</a>: Comprehensive I/O</h2>

<p>This SRFI defines a comprehensive I/O subsystem for Scheme with three layers, where each layer is built on top of the one below it:</p><ul><li>The lowest, primitive layer provides unbuffered I/O, and is close to what a typical operating system offers.</li><li>The middle layer builds on lazy, mostly functional buffered streams.</li><li>The upper layer is similar in nature to the ports subsystem in R5RS, and provides conventional, imperative buffered input and output.</li></ul><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, the subsystem provides</p><ul><li>buffered reading and writing</li><li>arbitrary lookahead at the streams level</li><li>dynamic redirection of input or output at the ports level</li><li>binary and text I/O, mixed if needed</li><li>translated data streams</li><li>unbuffered I/O at the primitive layer</li><li>the ability to create arbitrary I/O streams, such as to and from blobs and strings</li></ul><p>The subsystem does <em>not</em> provide</p><ul><li>formatted I/O</li><li>non-blocking or selective I/O</li><li>portable filenames, or any functionality for manipulating filenames</li><li>filesystem operations</li><li>socket I/O</li><li>extremely high-throughput or zero-copy I/O</li></ul><p>However, all of these could be added on top of one or several of the layers specified in this SRFI.</p>

<h2><a href="srfi-69/">SRFI 69</a>: Basic hash tables</h2>

<p>This SRFI defines basic hash tables.  Hash tables are widely recognised
as a fundamental data structure for a wide variety of applications.  A
hash table is a data structure that:

<ol><li>provides a mapping from some set of keys to some set of values
associated to those keys
<li>has no intrinsic order for the (key, value) associations it contains
<li>supports in-place modification as the primary means of setting the
contents of a hash table
<li>provides key lookup and destructive update in amortised constant
time, provided that a good hash function is used.

</ol><p>This SRFI aims to accomplish these goals:

<ol><li>to provide a consistent, generic and widely applicable API for hash
tables
<li>to improve code portability by providing a standard hash table
facility with guaranteed behaviour
<li>to help the programmer by defining utility routines that account for
the most common situations of using hash tables.

</ol>

<h2><a href="srfi-70/">SRFI 70</a>: Numbers</h2>

This SRFI proposes text to replace section 6.2 "Numbers" of R5RS in
order to extend its capabilities, correct errors in its specification,
make it more explicit about limitations of precision and magnitude,
and improve portability between implementations.  More specifically,
this new text:

<ul>

 <li> incorporates an inexact real positive infinity and an inexact
      real negative infinity,

 </li><li> extends number syntax to incorporate inexact real
      infinities,

 </li><li> adapts Common-Lisp semantics for <samp>`expt'</samp> and
      extends them to include inexact real infinities,

 </li><li> corrects the description of <samp>`sqrt'</samp>,

 </li><li> sharpens the distinction between exact and inexact numbers,

 </li><li> removes a contradiction related to exactness,

 </li><li> extends <samp>`gcd'</samp> and <samp>`lcm'</samp> to exact
      rational numbers,

 </li><li> extends <samp>`quotient'</samp>, <samp>`modulo'</samp>, and
      <samp>`remainder'</samp> to finite real numbers,

 </li><li> clarifies the behavior of <samp>`inexact-&gt;exact'</samp>
      applied to an exact argument,

 </li><li> clarifies the behavior of <samp>`exact-&gt;inexact'</samp>
      applied to an inexact argument,

 </li><li> adds convenience procedures <samp>`exact-round'</samp>,
      <samp>`exact-ceiling'</samp>, <samp>`exact-floor'</samp>, and
      <samp>`exact-truncate'</samp>,

 </li><li> and adds examples.

</li></ul>

<h2><a href="srfi-71/">SRFI 71</a>: Extended LET-syntax for multiple values</h2>

This SRFI is a proposal for extending <code>let</code>,
<code>let*</code>, and <code>letrec</code>
for receiving multiple values.
The syntactic extension is fully compatible with the existing syntax.
It is the intention that single-value bindings,
i.e. <code>(let ((var expr)) ...)</code>, and
multiple-value binding can be mixed freely and conveniently.
<p>
The most simple form of the new syntax is best explained by an example:
<p>
<pre>
(define (quo-rem x y)
  (values (quotient x y) (remainder x y)))

(define (quo x y)
  (let ((q r (quo-rem x y)))
    q))
</pre>
The procedure <code>quo-rem</code> delivers two values to
its continuation. These values are received as <code>q</code>
and <code>r</code> in the <code>let</code>-expression of the
procedure <code>quo</code>.
In other words, the syntax of <code>let</code> is extended such
that several variables can be specified---and these variables
receive the values delivered by the expression <code>(quo-rem x y)</code>.
<p>
The syntax of <code>let</code> is further extended to cases in which
a rest argument receives the list of all residual values.
Again by example,
<pre>
(let (((values y1 y2 . y3+) (foo x)))
   body)
</pre>
In this example, <code>values</code> is a syntactic keyword
indicating the presence of multiple values to be received,
and <code>y1</code>, <code>y2</code>, and <code>y3+</code>,
resp., are variables bound to the first value, the second value,
and the list of the remaining values, resp., as produced by
<code>(foo x)</code>.
The syntactic keyword <code>values</code> allows receiving
all values as in <code>(let (((values . xs) (foo x))) body)</code>.
It also allows receiving no values at all as in
<code>(let (((values) (for-each foo list))) body)</code>.
<p>
A common application of binding multiple values is
decomposing data structures into their components.
This mechanism is illustrated in its most primitive form as follows:
The procedure <code>uncons</code> (defined below)
decomposes a pair <code>x</code> into its car and its cdr
and delivers them as two values to its continuation.
Then an extended <code>let</code> can receive these values:
<pre>
(let ((car-x cdr-x (uncons x)))
  (foo car-x cdr-x))
</pre>
Of course, for pairs this method is probably neither faster
nor clearer than using the procedures <code>car</code>
and <code>cdr</code>.
However, for data structures doing substantial work upon
decomposition this is different: Extracting the element of
highest priority from a priority queue, while at the
same time constructing the residual queue,
can both be more efficient and more convenient than
doing both operations independently.
In fact, the <code>quo-rem</code> example illustrates this
point already as both quotient and remainder are probably
computed by a common exact division algorithm.
(And often caching is used to avoid executing this
algorithm twice as often as needed.)
<p>
As the last feature of this SRFI, a mechanism is specified
to store multiple values in heap-allocated data structures.
For this purpose, <code>values->list</code> and <code>values->vector</code>
construct a list (a vector, resp.) storing all values delivered
by evaluating their argument expression.
Note that these operations cannot be procedures.

<h2><a href="srfi-72/">SRFI 72</a>: Hygienic macros</h2>

This SRFI describes a procedural macro proposal for Scheme with the following
features:

<ul>
<li>
 <h3>Improved hygiene:</h3>
 <p>
 We argue that conventional hygiene algorithms may lead to
accidental variable capture
errors in procedural macros.  We propose an improved algorithm that avoids these problems.

</p><p>

</p></li><li>
 <h3>Reflective tower:</h3>
 <p>
We specify a reflective tower of arbitrary height,
and propose a refinement of lexical scoping that takes into account the
phase of use of an identifier in
determining its meaning.

</p><p>





</p><p>
</p></li><li>
 <h3>Syntax-case:</h3>
 <p>
In the current proposal, the <tt>syntax-case</tt> form is expressible as a macro in terms of a
simpler set of primitives and is specified as library syntax.

</p><p>
</p></li><li>
 <h3>Procedural interface:</h3>
 <p>
The primitive interface for manipulating compound syntax objects
consists of procedures
rather than special forms.  In particular,
   the traditional abstractions <tt>car</tt>, <tt>cdr</tt>, <tt>cons</tt>
, <tt>...</tt> can be used on syntactic data.

</p><p>
</p></li><li>
 <h3>Fast hygiene algorithm:</h3>
 <p>
   The reference implementation documents
   a fast imperative hygiene algorithm that is eager and
   linear in expression size.
</p><p>
</p>
<p></p><p>
</p></li><li>
 <h3>Capturing identifiers:</h3>
 <p>
  A primitive <tt>make-capturing-identifier</tt> is provided for intentional
  variable capture and for building
  expansion-time fluid binding constructs.
</p></li></ul>


<h2><a href="srfi-73/">SRFI 73</a>: Exact Infinities</h2>

Many Scheme implementations support exact arbitrary-precision
integer arithmetic as well as exact rational number computation. This SRFI
extends the rational numbers of R5RS by adding two rational infinities (1/0,
-1/0).
<P>With infinities added to the number system we find that division by zero
"works". It lets initialization of variables precede bounds checks and gives
flexibility in placement of those checks.</P>

<h2><a href="srfi-74/">SRFI 74</a>: Octet-Addressed Binary Blocks</h2>

<p>This SRFI defines a set of procedures for creating, accessing, and
  manipulating octet-addressed blocks of binary data, in short,
  <i>blobs</i>. The SRFI provides access primitives for fixed-length
  integers of arbitrary size, with specified endianness, and a choice
  of unsigned and two's complement representations.</p>

<h2><a href="srfi-75/">SRFI 75</a>: R6RS Unicode data</h2>

<p>

Unicode is a widespread universal character code that supports most of
the world's (natural) languages.  The extensions to Scheme specified
in this SRFI concern the support of Unicode in Scheme's character,
string, and symbol datatypes.  This SRFI does not (fully) specify how
I/O of Unicode data is performed or how Scheme source code is encoded
in files; these aspects are left for other SRFIs to specify.

</p>

<h2><a href="srfi-76/">SRFI 76</a>: R6RS Records</h2>

<p>This SRFI describes abstractions for creating new data types representing records - data structures with named fields.  This SRFI comes in four parts:</p><ul><li>a procedural layer for creating and manipulating record types and record
         instances</li><li>an explicit-naming syntactic layer for defining the various entities associated with a record type - construction procedure, predicate, field accessors, mutators, etc. - at once</li><li>an implicit-naming syntactic layer built on top of the explicit-naming syntactic layer, which chooses the names for the various products based on the names of the record type and fields</li><li>a set of reflection procedures</li></ul>

<h2><a href="srfi-77/">SRFI 77</a>: Preliminary Proposal for R6RS Arithmetic</h2>

<p>
Scheme's arithmetic system was designed to allow a wide variety of
implementations.  After many years of implementation experience,
however, most implementations now fall into a small number of
categories, and the benefits of continued experimentation no longer
justify the confusion and portability problems that have resulted from
giving implementations so much freedom in this area.  Moreover, the
R5RS generic arithmetic is difficult to implement as efficiently as
purely fixnum or purely flonum arithmetic.  (Fixnum arithmetic is
typically limited-precision integer arithmetic implemented using
one or more representations that may be especially efficient on
the executing machine; flonum arithmetic is typically
limited-precision floating-point arithmetic using one or more
representations that may be especially efficient on the executing
machine.)

<P>
This SRFI is an effort to extend and clarify the R5RS arithmetic to
make it more portable, more comprehensive, and enable faster programs.

<P>
Furthermore, one of us (Sperber) has argued that Scheme's arithmetic
requires radical overhaul.  The other (Clinger) agrees that revisions
are needed.  Whether these revisions qualify as radical is best left
to the judgement of individual readers.

<p>
This SRFI proposes to revise section 6.2 ("Numbers") of R5RS by:
</p>
<ul>
<li>requiring a Scheme implementation to provide the full tower,
    including exact rationals of arbitrary precision, exact
    rectangular complex numbers with rational real and imaginary
    parts, and inexact real and complex arithmetic
<li>defining fixnum arithmetic (parameterized by precision)
<li>defining flonum arithmetic (inexactly)
<li>defining new procedures for performing exact arithmetic
<li>defining new procedures for performing inexact arithmetic
<li>describing the external representation and semantics of
    0.0, -0.0, infinities and NaNs for systems
    that implement inexact real arithmetic using IEEE binary
    floating point
<li>changing the specification of <code>eqv?</code> to
    behave more sensibly with inexact numbers
<li>defining Scheme's real numbers to be the complex numbers
    whose imaginary part is an exact zero
<li>adding an external representation for inexact numbers
    that expresses the precision of a binary floating point
    representation
<li>defining procedures for some new operations, including integer
    division and remainder on real numbers, and bitwise operations,
<li>restricting the domains of some R5RS procedures
<li>clarifying the semantics of some R5RS procedures
<li>possibly changing the semantics of some R5RS procedures
</ul>

<h2><a href="srfi-78/">SRFI 78</a>: Lightweight testing</h2>

A simple mechanism is defined for testing Scheme programs.
As a most primitive example, the expression

<PRE>
   (check (+ 1 1) => 3)
</PRE>

evaluates the expression <CODE>(+ 1 1)</CODE> and compares the result
with the expected result 3 provided after the syntactic
keyword <CODE>=&gt;</CODE>. Then the outcome of this comparison is reported
in human-readable form by printing a message of the form

<PRE>
   (+ 1 1) => 2 ; *** failed ***
   ; expected result: 3
</PRE>

Moreover, the outcome of any executed check is recorded
in a global state counting the number of correct and failed
checks and storing the first failed check. At the end of a
file, or at any other point, the user can print a summary
using <CODE>check-report</CODE>.
<p>
In addition to the simple test above, it is also possible
to execute a parametric sequence of checks. Syntactically,
this takes the form of an eager comprehension in the sense
of <A HREF="srfi-42/">SRFI 42</A> [5]. For example,

<PRE>
   (check-ec (:range e 100)
             (:let x (expt 2.0 e))
             (= (+ x 1) x) => #f (e x))
</PRE>

This statement runs the variable <CODE>e</CODE> through {0..99} and
for each binding defines <CODE>x</CODE> as <CODE>(expt 2.0 e)</CODE>. Then it is
checked if <CODE>(+ x 1)</CODE> is equal to <CODE>x</CODE>, and it is expected that
this is not the case (i.e. expected value is <CODE>#f</CODE>). The
trailing <CODE>(e x)</CODE> tells the reporting mechanism to print
the values of both <CODE>e</CODE> and <CODE>x</CODE> in case of a failed check.
The output could look like this:

<PRE>
   (let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) => #t ; *** failed ***
    ; expected result: #f
</PRE>

The specification of bindings to report, <CODE>(e x)</CODE> in the
example, is optional but very informative.

Other features of this SRFI are:
<UL>
<LI>A way to specify a different equality predicate (default is <CODE>equal?</CODE>).</LI>
<LI>Controlling the amount of reporting being printed.</LI>
<LI>Switching off the execution and reporting of checks entriely.</LI>
<LI>Retrieving a boolean if all checks have been executed and passed.</LI>
</UL>

<h2><a href="srfi-79/">SRFI 79</a>: Primitive I/O</h2>

<p>This SRFI defines a simple, primitive I/O subsystem for Scheme that is intended to function as the lowest layer of a more comprehensive suite of I/O layers.  It provides unbuffered I/O, and is close to what a typical operating system offers. Thus, its interface is suitable for implementing high-throughput and zero-copy I/O.</p><p>The Primitive I/O layer also allows clients to implement custom data sources and sinks via a simple interface.</p><p>Moreover, this SRFI defines a condition hierarchy specifying common I/O-related exceptional situations.</p><p>The Primitive I/O layer only handles blocking-I/O.  Non-blocking and selective I/O is left for another SRFI.</p><p>This I/O layer was designed in conjunction with two other layers that can be built on top of it: <a href="srfi-80/">SRFI 80 (Stream I/O)</a> and <a href="srfi-81/">SRFI 81 (Port I/O)</a>.</p>

<h2><a href="srfi-80/">SRFI 80</a>: Stream I/O</h2>

<p>This SRFI defines an I/O layer for lazy, mostly functional buffered streams.</p><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, this layer provides</p><ul><li>buffered reading and writing</li><li>arbitrary lookahead</li><li>dynamic redirection of input or output</li><li>binary and text I/O, mixed if needed</li><li>translated data streams</li><li>the ability to create I/O streams from arbitrary readers and writers </li></ul><p>It builds on the Primitive I/O  layer specified in <a href="srfi-79/">SRFI 79 (Primitive I/O)</a>.</p>

<h2><a href="srfi-81/">SRFI 81</a>: Port I/O</h2>

<p>This SRFI defines an I/O layer similar in nature to the ports subsystem in R5RS, and provides conventional, imperative buffered input and output.</p><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, the subsystem fulfills the following requirements:</p><ul><li>buffered reading and writing</li><li>binary and text I/O, mixed if needed</li><li>the ability to create arbitrary I/O ports from readers and writers</li></ul><p>It builds on the Primitive I/O  layer specified in <a href="srfi-79/">SRFI 79 (Primitive I/O)</a>.</p>

<h2><a href="srfi-82/">SRFI 82</a>: Stream Ports</h2>

<p>This SRFI augments <a href="srfi-81/">SRFI 81 (Port I/O)</a> by allowing ports to be constructed from streams as described in <a href="srfi-80/">SRFI 80 (Stream I/O)</a>.</p>

<h2><a href="srfi-83/">SRFI 83</a>: R6RS Library Syntax</h2>

<p>The module system presented here is designed to let programmers
share libraries, i.e., code that is intended to be incorporated into
larger programs, and especially into programs that use library code
from multiple sources. The module system supports macro definitions
within modules, allows macro exports, and distinguishes the phases in
which definitions and imports are needed. This SRFI defines a standard
notation for libraries, a semantics for library expansion and
execution, and a simple format for sharing libraries.</p>

<!-- ISSUES -->

<h2><a href="srfi-84/">SRFI 84</a>: Universal Identifiers</h2>

<p>This SRFI proposes a social convention to allow programmers to
easily create short, simple Scheme symbols which are guaranteed to be
universally unique: No other programmer also following this SRFI will
accidentally create a symbol eq? to yours.

<p>Universally unique symbols are useful to identify standards,
languages, libraries, types, classes, and other resources.

<h2><a href="srfi-85/">SRFI 85</a>: Recursive Equivalence Predicates</h2>

<p>
This SRFI defines two related equivalence predicates that are
recursive, not just partial recursive: they terminate on all
arguments.
One of these predicates, <code>equiv?</code>, is consistent
with the <code>equal?</code> procedure described in the R5RS:
Whenever <code>equal?</code> terminates, <code>equiv?</code>
returns the same value as <code>equal?</code>.
</p>

<h2><a href="srfi-86/">SRFI 86</a>: MU and NU simulating VALUES & CALL-WITH-VALUES, and their related LET-syntax</h2>

<p>
Unlike the <code>values</code>/<code>call-with-values</code> mechanism of
R5RS, this SRFI uses an explicit representation for multiple return
values as a single value, namely a procedure.  Decomposition of
multiple values is done by simple application.  Each of the two
macros, <code>mu</code> and <code>nu</code>, evaluates to a procedure
that takes one procedure argument.  The <code>mu</code> and
<code>nu</code> can be compared with <code>lambda</code>.  While
<code>lambda</code> expression that consists of &lt;formals&gt; and &lt;body&gt;
requires some actual arguments later when the evaluated
<code>lambda</code> expression is called, <code>mu</code> and
<code>nu</code> expressions that consist of &lt;expression&gt;s
corresponding to actual arguments of <code>lambda</code> require
&lt;formals&gt; and &lt;body&gt;, that is, an evaluated <code>lambda</code>
expression, later when the evaluated <code>mu</code> and
<code>nu</code> expressions are called.
    </p>

<p>
This SRFI also introduces new <code>let</code>-syntax depending on
<code>mu</code> and <code>nu</code> to manipulate multiple values,
<code>alet</code> and <code>alet*</code> that are compatible with
<code>let</code> and <code>let*</code> of R5RS in single value
bindings.  They also have a binding form making use of
<code>values</code> and <code>call-with-values</code> to handle
multiple values.  In addition, they have several new binding forms for
useful functions such as escape, recursion, etc.
    </p>

<h2><a href="srfi-87/">SRFI 87</a>: => in case clauses</h2>

This SRFI proposes an extension to the <CODE>case</CODE> syntax
to allow the <CODE>=&gt;</CODE> clauses as in <CODE>cond</CODE>.

<h2><a href="srfi-88/">SRFI 88</a>: Keyword objects</h2>

<P>
This SRFI defines <I>keyword</I> objects, a data type similar to
Scheme symbols.  Keyword objects have the same lexical syntax as
symbols but they must end in a colon.  Moreover keyword objects
are self-evaluating.
Procedures for converting between strings and keyword objects
(<TT>string-&gt;keyword</TT> and <TT>keyword-&gt;string</TT>)
and a type predicate (<TT>keyword?</TT>) are defined.  Finally
this SRFI specifies the changes to the Scheme lexical syntax required
to accomodate keywords.
</P>

<h2><a href="srfi-89/">SRFI 89</a>: Optional positional and named parameters</h2>

<P>
This SRFI specifies the <TT>define*</TT> and <TT>lambda*</TT> special forms.
These forms extend the R5RS <TT>define</TT> and <TT>lambda</TT> special forms
to simplify the use of optional positional and named
parameters.  Optional positional
parameters, optional named parameters and required named parameters
are covered by this SRFI.  The formal parameter list syntax specified
in this SRFI is different from the syntax used by Common Lisp and the
DSSSL languages but nevertheless offers similar functionality and a
nicer syntax.  Formal parameter lists which conform to the R5RS syntax
have the same meaning as in R5RS.
</P>

<h2><a href="srfi-90/">SRFI 90</a>: Extensible hash table constructor</h2>

<P>
This SRFI specifies the procedure <TT>make-table</TT>, a hash table
constructor compatible with <a href="srfi-69/">SRFI 69
(Basic hash tables)</a>.  The procedure <TT>make-table</TT>
allows various parameters of the hash
table to be specified with optional named parameters when it is
constructed.  These parameters are: the initial size, the minimum and
maximum load factor, the key equivalence function, the key hashing
function, whether the references to the keys are weak, and similarly
for the values.  By using optional named parameters, as specified in
<a href="srfi-89/">SRFI 89 (Optional positional and named parameters)</a>, the constructor's API can be easily
extended in a backward compatible way by other SRFIs and Scheme
implementations.
<P>

<h2><a href="srfi-91/">SRFI 91</a>: Extended ports</h2>

<P>
This SRFI specifies an extension to the R5RS ports that supports
several useful features: binary I/O and text I/O, bulk I/O, file
opening attributes, and bidirectional ports.  Binary I/O is provided
through byte ports which are ports whose fundamental I/O unit is an 8
bit byte.  Because characters can be encoded with bytes using a
character encoding such as ISO 8859-1, UTF-8, and UTF-16BE,
any byte port is also a character port (a port that supports the
character level I/O of R5RS).  A byte port's character encoding and
various other attributes are specified when the port is opened.
Because reasonable defaults exist, these attributes are specified
using a named optional parameter syntax.  All procedures which have
the same name as in R5RS are compatible with R5RS but may provide
additional functionality.
</P>

<h2><a href="srfi-92/">SRFI 92</a>: ALAMBDA and ALAMBDA*</h2>

<p>This SRFI introduces ALAMBDA and ALAMBDA*, each of which has two modes of
operation:

  <ol>
    <li>it creates a procedure that checks actual arguments and takes
      optional arguments,</li>
    <li>it returns a different procedure by checking each of actual
      arguments and the number of them.</li></ol></p>

<h2><a href="srfi-93/">SRFI 93</a>: R6RS Syntax-Case Macros</h2>

<p>
The syntactic abstraction system described here extends the R5RS macro
system with support for writing low-level macros in a high-level style,
with automatic syntax checking, input destructuring, output restructuring,
maintenance of lexical scoping and referential transparency (hygiene), and
support for controlled identifier capture, with constant expansion
overhead.
Because it does not require literals, including quoted lists or vectors,
to be copied or even traversed, it preserves sharing and cycles within and
among the constants of a program.
It also supports source-object correlation, i.e., the maintenance of ties
between the original source code and expanded output, allowing
implementations to provide source-level support for debuggers and other
tools.

<p>

<h2><a href="srfi-94/">SRFI 94</a>: Type-Restricted Numerical Functions</h2>

In the coding of numerial calculations in latent-typed languages it is
good practice to assure that those calculations are using the intended
number system.  The most common number systems for programmatic
calculations are the integers, reals, and complexes.  This SRFI
introduces 14 real-only and 3 integer-only variants of R5RS procedures
to facilitate numerical type checking and declaration.
<p>

<h2><a href="srfi-95/">SRFI 95</a>: Sorting and Merging</h2>

Sorting and Merging are useful operations deserving a common API.
<p>

<h2><a href="srfi-96/">SRFI 96</a>: SLIB Prerequisites</h2>

This SRFI specifies a set of procedures and macros presenting a
uniform interface sufficient to host the
<A HREF="http://swiss.csail.mit.edu/~jaffer/SLIB">SLIB
Scheme Library</A> system.
<p>

<h2><a href="srfi-97/">SRFI 97</a>: SRFI Libraries</h2>

<p>Over the past ten years, numerous libraries have been specified via
the Scheme Requests for Implementation process.  Yet until the recent
ratification of the Revised<sup>6</sup> Report on the Algorithmic
Language Scheme, there has been no standardized way of distributing or
relying upon library code.  Now that such a library system exists,
there is a real need to organize these existing SRFI libraries so that
they can be portably referenced.</p>

<p>This SRFI is designed to facilitate the writing and distribution of
code that relies on SRFI libraries.  It identifies a subset of
existing SRFIs that specify features amenable to provision (and
possibly implementation) as libraries (SRFI Libraries) and proposes a
naming convention for this subset so that these libraries may be
referred to by name or by number.

<!--
This convention represents a consensus among current R<sup>6</sup>RS
implementors.
-->

</p>

<h2><a href="srfi-98/">SRFI 98</a>: An interface to access environment variables</h2>

This SRFI specifies the procedure get-environment-variable, which gets
the value of the specified environment variable, and the procedure
get-environment-variables, which gets an association list of all
environment variables.

<h2><a href="srfi-99/">SRFI 99</a>: ERR5RS Records</h2>

<p>
Many Scheme programmers have considered records to be one
of the most important features missing from the R5RS.
The R6RS proposed a record system, but its design has
been widely criticized and it was not intended for use
in R5RS programs anyway.
</p>

<p>
This SRFI proposes a better record system for use in R5RS,
ERR5RS, and R6RS programs.  The syntactic layer of this
SRFI's record system is an extension of SRFI 9.  The
procedural and inspection layers of this SRFI's record
system are perfectly compatible with its syntactic layer.
This entire SRFI is compatible with the procedural and
inspection layers of the R6RS record system, but offers
several worthwhile improvements over the R6RS system.
</p>


<h2><a href="srfi-100/">SRFI 100</a>: define-lambda-object</h2>

<p>This SRFI introduces a macro, DEFINE-LAMBDA-OBJECT which defines a
set of procedures, that is, a group, two constructors, and a
predicate.  The constructors also make a group of procedures, namely
lambda objects.  The macro extends DEFINE-RECORD-TYPE (SRFI 9) in
being more general but much less general than DEFCLASS (CLOS).  The
macro has no explicit field accessors and mutators but parent groups,
required fields, optional fields, automatic fields, read-write fields,
read-only fields, inaccessible hidden fields, immutable virtual
fields, and common sharing fields.</p>

<h2><a href="srfi-101/">SRFI 101</a>: Purely Functional Random-Access Pairs and Lists</h2>

<p>
Random-access lists [1] are a purely functional
data structure for representing lists of values. A random-access list
may act as a drop in replacement for the usual linear-access pair and
list data structures
(<code>pair?</code>, <code>cons</code>, <code>car</code>, <code>cdr</code>),
which additionally supports fast index-based addressing and updating
(<code>list-ref</code>, <code>list-set</code>).  The impact is a whole
class of purely-functional algorithms expressed in terms of
index-based list addressing become feasible compared with their
linear-access list counterparts.
</p>


<p>
This document proposes a library API for purely functional
random-access lists consistent with the R<sup>6</sup>RS
[2] base library and list utility standard
library [3].
</p>

<h2><a href="srfi-102/">SRFI 102</a>: Procedure Arity Inspection</h2>

<p>
Many Scheme systems provide mechanisms for inspecting the arity of a
procedural value, making it a common feature, however there is no
standard interface.  As a result there is no portable way to observe
the arity of a procedure <em>without actually applying it</em>.  This
SRFI proposes a simple interface that is consistent with existing
Scheme systems' facilities and prior proposals.
</p>

<h2><a href="srfi-103/">SRFI 103</a>: Library Files</h2>

<p>This SRFI defines a standard for locating files containing libraries with
list-of-symbols library names, for unixes and Windows.  It defines a standard
for files containing R6RS libraries.  It supports different Scheme dialects.</p>

<!-- ======================================================================= -->

<h2><a href="srfi-104/">SRFI 104</a>: Library Files Utilities</h2>

<p>This SRFI implements <a href="srfi-103/">
SRFI&nbsp;103: Library Files</a> as a library.  It is useful for working with
library files.</p>

<!-- ======================================================================= -->

<h2><a href="srfi-105/">SRFI 105</a>: Curly-infix-expressions</h2>

<p>Lisp-based languages, like Scheme, are almost the only
programming languages in modern use that do not support infix notation.
In addition, most languages allow infix expressions to be combined
with function call notation of the form
<code><var>f</var>(<var>x</var>)</code>.
This SRFI provides these capabilities, both for
developers who already use Scheme and want these conveniences,
and also for other developers who may choose to use other languages
in part because they miss these conveniences.
Scheme currently reserves <code>{</code>...<code>}</code>
&#8220;for possible future extensions to the language&#8221;.
We propose that <code>{</code>...<code>}</code> be used
to support &#8220;curly-infix-expression&#8221; notation as a homoiconic
infix abbreviation,
as a modification of the Scheme reader.
It is an abbreviation in much the same way that
<samp>&#39;x</samp> is an abbreviation for <samp>(quote&nbsp;x)</samp>.
</p>
<p>
A
<dfn>curly-infix list</dfn>
introduces a list whose visual presentation
can be in infix order instead of prefix order.
For example,
<samp>{n&nbsp;&gt;&nbsp;5}</samp> &#8658; <samp>(&gt;&nbsp;n&nbsp;5)</samp>,
and
<samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c}</samp> &#8658;
<samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>.
By intent, there is no precedence, but e.g.,
<samp>{x&nbsp;+&nbsp;{y&nbsp;*&nbsp;z}}</samp>
maps cleanly to
<samp>(+&nbsp;x&nbsp;(*&nbsp;y&nbsp;z))</samp>.
Forms with mixed infix operators and other complications have
&#8220;<code>$nfx$</code>&#8221; prepended to
enable later processing, e.g.,
<samp>{4&nbsp;+&nbsp;5&nbsp;*&nbsp;6}</samp> &#8658;
<samp>($nfx$&nbsp;4&nbsp;+&nbsp;5&nbsp;*&nbsp;6)</samp>.
Also, inside a curly-infix list (recursively),
expressions of the form <code><var>f</var>(</code>...<code>)</code> are simply
an abbreviation for <code>(<var>f</var>&nbsp;</code>...<code>)</code>.</p>

<p>Note that this is derived from the
&#8220;<a href="http://readable.sourceforge.net/">readable</a>&#8221;
project.
We intend to later submit at least one additional SRFI that will build on
top of this SRFI, but curly-infix-expressions are useful on their own.
</p>

<h2><a href="srfi-106/">SRFI 106</a>: Basic socket interface</h2>

This document specifies basic socket interfaces.

<h2><a href="srfi-107/">SRFI 107</a>: XML reader syntax</h2>

<p>
We specify a reader extension that reads data in a superset of
XML/HTML format, and produces conventional S-expressions.
We also suggest a possible semantics interpretation of how these forms
may be evaluated to produce XML-node values, but this is non-normative.

<h2><a href="srfi-108/">SRFI 108</a>: Named quasi-literal constructors</h2>

<p>
This specifies an extensible reader syntax for
named value constructors.
A reader prefix is followed by a <q>tag</q> (an identifier),
and then expressions and literal text parameters.
The tag can be though of as a class name, and the expression and
literal text are arguments to an object constructor call.
The reader translates <code>&amp;<var>tag</var>{...}</code> to a list
<code>($construct$:<var>tag</var> ...)</code>,
where <code>$construct$:<var>tag</var></code>
is normally bound to a predefined macro.
<p>
This propsal depends on
<a href="srfi-109/">SRFI-109 (extended string quasi-literals)</a> (in spite of having a lower number).
It also shares quite of bit of syntax with
<a href="srfi-107/">SRFI-107 (XML reader syntax)</a>.

<h2><a href="srfi-109/">SRFI 109</a>: Extended string quasi-literals</h2>

<p>
This specifies a reader extension for extended string quasi-literals,
including nicer multi-line strings, and enclosed unquoted expressions.
<p>
This proposal is related to
<a href="srfi-108/">SRFI-108 (extended string quasi-literals)</a> and <a href="srfi-107/">SRFI-107 (XML reader syntax)</a>,
as they share quite a bit of syntax.

<h2><a href="srfi-110/">SRFI 110</a>: Sweet-expressions (t-expressions)</h2>

<p>
This SRFI describes a set of syntax extensions for Scheme,
called sweet-expressions (t-expressions),
that has the same descriptive power as s-expressions
but is designed to be easier for humans to read.
The sweet-expression syntax enables the use of syntactically-meaningful
indentation to group expressions (similar to Python),
and it builds on the infix and traditional function notation defined in
<a href="srfi-105/">SRFI-105 (curly-infix-expressions)</a>.
Unlike nearly all past efforts to improve s-expression readability,
sweet-expressions are
general (the notation is independent from any underlying semantic)
and homoiconic (the underlying data structure is clear from the syntax).
This notation was developed by the
&#8220;<a href="http://readable.sourceforge.net/">Readable Lisp S-expressions Project</a>&#8221; and
can be used for both programs and data.
</p>
<p>
Sweet-expressions can be considered
a set of additional abbreviations, just as <tt>'x</tt> already abbreviates
<tt>(quote&nbsp;x)</tt>.
Sweet-expressions and traditionally formatted s-expressions
can be freely mixed; this provides backwards compatibility,
simplifies transition, and enables developers to maximize readability.
Here is an example of a sweet-expression and its equivalent s-expression
(note that a sweet-expression reader would accept <em>either</em> format):
</p>

<table border="1" cellpadding="4">
<tr><th>sweet-expression</th><th>s-expression</th></tr>
<tr>
<td>
<pre>
define fibfast(n)   ; Typical function notation
  if {n &lt; 2}        ; Indentation, infix {...}
     n              ; Single expr = no new list
     fibup n 2 1 0  ; Simple function calls
</pre>
</td>
<td>
<pre>
(define (fibfast n)
  (if (&lt; n 2)
      n
      (fibup n 2 1 0)))
</pre>
</td>
</tr>
</table>


<!-- SRFI-97 has a TOC; we think a TOC would be helpful here too. -->

<h2><a href="srfi-111/">SRFI 111</a>: Boxes</h2>

<p>Boxes are objects with a single mutable state. Several Schemes have them, sometimes called <i>cells</i>.  A constructor, predicate, accessor, and mutator are provided.</p>

<h2><a href="srfi-112/">SRFI 112</a>: Environment Inquiry</h2>

<p>This is a proposal for environment inquiry, providing
  human-readable information <em>at run time</em> about the hardware
  and software configuration on which a Scheme program is being
  executed.  They are mostly based on Common Lisp, with additions from
  the Posix <code>uname()</code> system call.</p>

<h2><a href="srfi-113/">SRFI 113</a>: Sets and bags</h2>

<p><em>Sets</em> and <em>bags</em> (also known as multisets) are unordered collections that can contain any Scheme object.  Sets enforce the constraint that no two elements can be the same in the sense of the set's associated <em>equality predicate</em>; bags do not.

</p>

<h2><a href="srfi-114/">SRFI 114</a>: Comparators</h2>

<p>This proposal is a rewrite of <a href="srfi-67/">SRFI 67</a>, Compare Procedures, extending it from procedures that represent a total order to procedure bundles that represent one or more of a total order, an equality predicate, and a hash function.  By packaging these procedures together, along with a type test predicate, they can be treated as a single item for use in the implementation of data structures.</p>

<h2><a href="srfi-115/">SRFI 115</a>: Scheme Regular Expressions</h2>

<p>
  This SRFI provides a library for matching strings with regular
  expressions described using the SRE "Scheme Regular Expression"
  notation first introduced by SCSH, and
  extended heavily by IrRegex.

<p>

<h2><a href="srfi-116/">SRFI 116</a>: Immutable List Library</h2>

<p>
Scheme currently does not provide immutable pairs corresponding to its existing mutable pairs, although most uses of pairs do not exploit their mutability.  The <a href="http://www.racket-lang.org">Racket</a> system takes the radical approach of making Scheme's pairs immutable, and providing a minimal library of mutable pairs with procedures named <code>mpair?, mcons, mcar, mcdr, set-mcar!, set-mcdr!</code>.  This SRFI takes the opposite approach of leaving Scheme's pairs unchanged and providing a full set of routines for creating and dealing with immutable pairs.  The sample implementation is portable (to systems with SRFI 9) and efficient.</p>

<h2><a href="srfi-117/">SRFI 117</a>: Mutable Queues</h2>

<p>
List queues are mutable ordered collections that can contain any Scheme object.  Each list queue is based on an ordinary Scheme list containing the elements of the list queue by maintaining pointers to the first and last pairs of the list.  It's cheap to add or remove elements from the front of the list or to add elements to the back, but not to remove elements from the back.  List queues are disjoint from other types of Scheme objects.
</p>

<h2><a href="srfi-118/">SRFI 118</a>: Simple adjustable-size strings</h2>

<p>
Scheme specifies mutable fixed-length strings.
We add two procedures <code>string-append!</code> and
<code>string-replace!</code> which allow the size of the string to change.
We also require that the standard Scheme procedures <code>make-string</code>
and <code>string-copy</code> return variable-size strings.

</p>

<h2><a href="srfi-119/">SRFI 119</a>: wisp: simpler indentation-sensitive scheme</h2>

<p>
This SRFI describes a simple syntax which allows making scheme easier to read for newcomers while keeping the simplicity, generality and elegance of s-expressions. Similar to <a href="srfi-110/">SRFI 110</a>, <a href="srfi-49/">SRFI 49</a> and Python it uses indentation to group expressions. Like <a href="srfi-110/">SRFI 110</a> wisp is general and homoiconic.
</p>

<p>
Different from its predecessors, wisp only uses the absolute minimum of additional syntax-elements which are required for writing and exchanging arbitrary code-structures. As syntax elements it only uses a colon surrounded by whitespace, the period followed by whitespace as first code-character on the line and optional underscores followed by whitespace at the beginning of the line.
</p>

<p>
It resolves a limitation of <a href="srfi-110/">SRFI 110</a> and <a href="srfi-49/">SRFI 49</a>, both of which force the programmer to use a single argument per line if the arguments to a procedure need to be continued after a procedure-call.
</p>

<p>
Wisp expressions can include arbitrary s-expressions and as such provide backwards compatibility.
</p>

<blockquote>
<table><tr><th>wisp</th><th>s-exp</th></tr><tr><td>
<pre>
<b>define</b> : <i>factorial</i> n
__  <b>if</b> : <i>zero?</i> n
____   . 1
____   <i>*</i> n : <i>factorial</i> (- n 1)

<i>display</i> : <i>factorial</i> 5
<i>newline</i>
</pre>
</blockqote>
</td><td>
<pre>
(<b>define</b> (<i>factorial</i> n)
    (<b>if</b> (<i>zero?</i> n)
       1
       (<i>*</i> n (<i>factorial</i> (- n 1)))))

(<i>display</i> (<i>factorial</i> 5))
(<i>newline</i>)
</pre>
</td></tr></table>
</blockquote>

<h2><a href="srfi-120/">SRFI 120</a>: Timer APIs</h2>

<p>This SRFI defines interfaces to handle timer processes.</p>

<h2><a href="srfi-121/">SRFI 121</a>: Generators</h2>

<p>This SRFI defines utility procedures that create, transform, and consume generators.
A generator is simply a procedure with no arguments that works
as a source of a series of values.  Every time it is called,
it yields a value.  Generators may be finite or infinite; a finite
generator returns an end-of-file object to indicate that it is exhausted.
For example, <code>read-char</code>, <code>read-line</code>,
and <code>read</code> are generators that
generate characters, lines, and objects from the current input port.
Generators provide lightweight laziness.
</p>

<h2><a href="srfi-122/">SRFI 122</a>: Nonempty Intervals and Generalized Arrays</h2>

<p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general; at their most basic, an array is simply a mapping, or function, from multi-indices of exact integers $i_0,\ldots,i_{d-1}$ to Scheme values.  The set of multi-indices $i_0,\ldots,i_{d-1}$ that are valid for a given array form the <i>domain</i> of the array.  In this SRFI, each array's domain consists  of a rectangular interval $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$, a subset of $\mathbb Z^d$, $d$-tuples of integers.  Thus, we introduce a data type called <i>intervals</i>, which encapsulate the cross product of nonempty intervals of exact integers. Specialized variants of arrays are specified to provide portable programs with efficient representations for common use cases.</p>

<h2><a href="srfi-123/">SRFI 123</a>: Generic accessor and modifier operators</h2>

<p>Lisp dialects including Scheme have traditionally lacked short,
  simple, generic syntax for accessing and modifying the fields of
  arbitrary &quot;collection&quot; objects. We fill this gap for
  Scheme by defining generalized accessors, and an associated SRFI-17
  setter.</p>

<h2><a href="srfi-124/">SRFI 124</a>: Ephemerons</h2>

<p>
An ephemeron is an object with two components called its <em>key</em> and its <em>datum</em>.  It differs from an ordinary pair as follows:  if the garbage collector (GC) can prove that there are no references to the key except from the ephemeron itself and possibly from the datum, then it is free to <em>break</em> the ephemeron, dropping its reference to both key and datum.  In other words, an ephemeron can be broken when nobody else cares about its key.  Ephemerons can be used to construct weak vectors or lists and (possibly in combination with finalizers) weak hash tables.
</p>

<p>Much of this specification is derived with thanks from the MIT Scheme Reference Manual.</p>

<h2><a href="srfi-125/">SRFI 125</a>: Intermediate hash tables</h2>

<p>
This SRFI defines an interface to hash tables, which are widely
recognized as a fundamental data structure for a wide variety of
applications.  A hash table is a data structure that:
</p>
<ul><li>Is disjoint from all other types.
</li><li>Provides a mapping from objects known as <em>keys</em>
to corresponding objects known as <em>values</em>.
<ul><li>Keys may be any Scheme objects in some kinds of hash tables,
but are restricted in other kinds.
</li><li>Values may be any Scheme objects.
</li></ul></li><li>Has no intrinsic order for the key-value
<em>associations</em> it contains.
</li><li>Provides an <em>equality predicate</em> which defines
when a proposed key is the same as an existing key.  No table
may contain more than one value for a given key.
</li><li>Provides a <em>hash function</em> which maps a candidate
key into a non-negative exact integer.
</li><li>Supports mutation as the primary means of setting the
contents of a table.
</li><li>Provides key lookup and destructive update in (expected)
amortized constant time, provided a satisfactory hash function is available.
</li><li>Does not guarantee that whole-table operations work in
the presence of concurrent mutation of the whole hash table
(values may be safely mutated).
</li></ul>

<h2><a href="srfi-126/">SRFI 126</a>: R6RS-based hashtables</h2>

<p>We provide a hashtable API that takes the R6RS hashtables API as a
  basis and makes backwards compatible additions such as support for
  weak hashtables, external representation, API support for double
  hashing implementations, and utility procedures.</p>

<h2><a href="srfi-127/">SRFI 127</a>: Lazy Sequences</h2>

<p>
Lazy sequences (or lseqs, pronounced "ell-seeks") are a generalization of lists.
In particular, an lseq is either a proper list or a dotted list
whose last cdr is
a <a href="srfi-121/">SRFI 121</a> generator.
A generator is a procedure that can be invoked with no arguments
in order to lazily supply additional elements of the lseq.
When a generator has no more elements to return, it returns an
end-of-file object.  Consequently, lazy sequences cannot reliably contain
end-of-file objects.</p>
<p>This SRFI provides a set of procedures
suitable for operating on lazy sequences based
on <a href="srfi-1/">SRFI 1</a>.</p>

<h2><a href="srfi-128/">SRFI 128</a>: Comparators (reduced)</h2>

<p>
This SRFI provides <i>comparators</i>, which bundle a type test predicate,
an equality predicate, an ordering predicate, and a hash function (the
last two are optional) into a single Scheme object.  By packaging these
procedures together, they can be treated as a single item for use in
the implementation of data structures.
</p>

<h2><a href="srfi-129/">SRFI 129</a>: Titlecase procedures</h2>

<p>
This SRFI defines R7RS-style  <tt>char-title-case?</tt>,
<tt>char-titlecase</tt>, and <tt>string-titlecase</tt> procedures.
</p>

<h2><a href="srfi-130/">SRFI 130</a>: Cursor-based string library</h2>

<p>

<abbr title="Revised<sup>5</sup> Report on Scheme">R5RS</abbr>
Scheme has an impoverished set of string-processing utilities, which is a
problem for authors of portable code. Although
<abbr title="Revised<sup>7</sup> Report on Scheme">R7RS</abbr>
provides some extensions and improvements, it is still very incomplete.
This <abbr title="Scheme Request for
Implementation">SRFI</abbr> proposes a coherent and comprehensive set of
string-processing procedures; it is accompanied by a portable sample implementation
of the spec.
<p>This SRFI is derived from SRFI 13.  The biggest difference is that it
allows subsequences of strings to be specified by
<em>cursors</em> as well as the traditional string indexes.
In addition, it omits the comparison, case-mapping, and mutation operations
of SRFI 13, as well as all procedures already present in
<abbr title="Revised<sup>7</sup> Report on Scheme">R7RS</abbr>.

<!--========================================================================-->

<h2><a href="srfi-131/">SRFI 131</a>: ERR5RS Record Syntax (reduced)</h2>

<p>This SRFI is a reduced version of the SRFI 99 syntactic layer
that can be implemented with <tt>syntax-rules</tt> without requiring
low-level macros.  Like SRFI-99's syntax layer, it is backward
compatible with the <code>define-record-type</code> macro from
<a href="srfi-9/">SRFI 9</a>
or R7RS-small.  It is forward compatible with
<a href="srfi-99/">SRFI 99</a>.
</p>

<h2><a href="srfi-132/">SRFI 132</a>: Sort Libraries</h2>

<p>
This SRFI describes the API for a full-featured sort toolkit.
</p>

<h2><a href="srfi-133/">SRFI 133</a>: Vector Library (R7RS-compatible)</h2>

<p>This SRFI proposes a comprehensive library of
  vector operations accompanied by a freely available and complete
  reference implementation.  The reference implementation is
  unencumbered by copyright, and useable with no modifications on any
  Scheme system that is R5RS-compliant.  It also
  provides several hooks for implementation-specific optimization as
  well.</p>

<h2><a href="srfi-134/">SRFI 134</a>: Immutable Deques</h2>

<p>
This SRFI defines immutable deques. A deque is a double-ended queue, a sequence which allows elements to be added or removed efficiently from either end.  A structure is immutable when all its operations leave the structure unchanged. Note that none of the procedures specified here ends with an exclamation point.</p>

<h2><a href="srfi-135/">SRFI 135</a>: Immutable Texts</h2>

<p>
In Scheme, strings are a mutable data type.
Although it "is an error"
(<abbr title="Revised<sup>5</sup> Report on Scheme">R5RS</abbr>
and
 <abbr title="Revised<sup>7</sup> Report on Scheme">R7RS</abbr>)
to use <code>string-set!</code>
on literal strings or on strings returned by <code>symbol-&gt;string</code>,
and any attempt to do so "should raise an exception"
(<abbr title="Revised<sup>6</sup> Report on Scheme">R6RS</abbr>),
all other strings are mutable.
</p>

<p>
Although many mutable strings are never actually mutated, the mere
possibility of mutation complicates specifications of libraries that
use strings, encourages precautionary copying of strings, and precludes
structure sharing that could otherwise be used to make procedures such
as <code>substring</code> and <code>string-append</code> faster and
more space-efficient.
</p>

<p>
This
<abbr title="Scheme Request for Implementation">SRFI</abbr>
specifies a new data type of immutable texts.
It comes with efficient and portable sample implementations
that guarantee O(1) indexing
for both sequential and random access, even in systems whose
<code>string-ref</code> procedure takes linear time.
</p>

<p>
The operations of this new data type include analogues for all
of the non-mutating operations on strings specified by
the R7RS and most of those specified by
<abbr title="String cursors"><a href="srfi-130/">SRFI 130</a></abbr>,
but the immutability of texts and
uniformity of character-based indexing simplify the
specification of those operations while avoiding several
inefficiencies associated with the mutability of Scheme's
strings.
</p>

<h2><a href="srfi-136/">SRFI 136</a>: Extensible record types</h2>

<p>
  SRFI 9 and the compatible R7RS-small provide Scheme with record
  types. The basic problem that is solved by these record types is that
  they allow the user to introduce new types, disjoint from all existing
  types. The record type system described in this document is a
  conservative extension to SRFI 9 and R7RS record types (in other words, the
  keyword <code>define-record-type</code> defined in this specification
  can serve as the equally named keyword from SRFI 9 and R7RS and can thus
  be safely exported from <code>(srfi 9)</code> and <code>(scheme base)</code>)
  that is intended to
  solve another fundamental problem, namely the introduction of subtypes.
</p>

<h2><a href="srfi-137/">SRFI 137</a>: Minimal Unique Types</h2>

This SRFI is intended to standardize a primitive run-time mechanism to
create disjoint types.

<h2><a href="srfi-138/">SRFI 138</a>: Compiling Scheme programs to executables</h2>

<p>
  This SRFI describes, for sufficiently POSIX-compatible systems,
  a portable interface for compiling Scheme programs
  conforming to the R7RS to binaries that can be directly executed on the
  host system.
</p>

<h2><a href="srfi-139/">SRFI 139</a>: Syntax parameters</h2>

<p>
Syntax parameters are to the expansion process of a Scheme program
what parameters are to the evaluation process of a Scheme program. They allow
hygienic implementation of syntactic forms that would otherwise
introduce implicit identifiers unhygienically.
</p>

<h2><a href="srfi-140/">SRFI 140</a>: Immutable Strings</h2>

<p>This attempts to solve the same issues with R7RS strings raised by
  <a href="srfi-135/">SRFI-135</a>,
  but with better integration with the Scheme language.</p>

<p>
We propose to retain the name <dfn>string</dfn> as
the type of sequences of Unicode characters (scalar values).
There are two standard subtypes of string:
<ul>
<li>Immutable strings, also called <dfn>istrings</dfn>, cannot be
modified after they have been created.  Calling <code>string-set!</code>
on an istring throws an error.
On the other hand, the core operations <code>string-ref</code> and
<code>string-length</code> are guaranteed to be O(1).
<li>Mutable strings can be modified <q>in-place</q> using
<code>string-set!</code> and other operations.
However, <code>string-ref</code>, <code>string-set!</code>,
or <code>string-length</code> have no performance guarantees.
On many implementation they may take time proportional to the
length of the string.
</ul>
An implementation may support other kinds of strings.
For example on the Java platform it may be reasonable to
consider any instance of <code>java.lang.CharSequence</code> to be a string.
<p>
The main part of the proposal specifies the default bindings of various procedure names,
as might be pre-defined in a REPL.  Specifically, some procedures
that traditionally return mutable strings are changed to return istrings.
We later discuss compatibility and other library issues.
<p>
This combines
<a href="srfi-13/">SRFI-13</a>,
<a href="srfi-135/">SRFI-135</a>,
and <a href="srfi-118/">SRFI-118</a>.

<h2><a href="srfi-141/">SRFI 141</a>: Integer division</h2>

<p>
This SRFI provides a fairly complete set of integral division and
remainder operators.
</p>

<h2><a href="srfi-142/">SRFI 142</a>: Bitwise Operations</h2>

<p>
This SRFI proposes a coherent and comprehensive set of procedures for
performing bitwise logical operations on integers; it is
accompanied by a reference implementation of the spec in terms of a set of
seven core operators. The sample implementation is portable, as efficient
as practical with pure Scheme arithmetic (it is worthwhile replacing the
core operators with C or assembly language if possible), and open source.
</p>
<p>
The precise semantics of these operators is almost never an issue. A
consistent, portable set of <em>names</em> and <em>parameter conventions</em>, however, is.
Hence this SRFI, which is based mainly on <a href="srfi-33/">SRFI 33</a>, with some changes and additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late revisions to SRFI 33</a> (which were never consummated).
<a href="srfi-60/">SRFI 60</a>
(based on SLIB) is smaller but has a few procedures of its own;
some of its procedures have both native (often Common Lisp) and SRFI 33 names.
They have been incorporated into this SRFI.
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">R6RS</a>
is a subset of SRFI 60, except that all procedure names begin with a <tt>bitwise-</tt> prefix.
A few procedures have been added from
the general vector <a href="srfi-133/">SRFI 133</a>.
</p>
<p>
Among the applications of bitwise operations are: hashing,
Galois-field calculations of error-detecting and error-correcting codes,
cryptography and ciphers,
pseudo-random number generation,
register-transfer-level modeling of digital logic designs,
Fast-Fourier transforms,
packing and unpacking numbers in persistent data structures,
space-filling curves with applications to dimension reduction
and sparse multi-dimensional database indexes,
and generating approximate seed values for root-finders
and transcendental function algorithms.
</p>

<h2><a href="srfi-143/">SRFI 143</a>: Fixnums</h2>

<p>This SRFI describes arithmetic procedures applicable to a limited range of exact integers only.
These procedures are semantically similar to the corresponding generic-arithmetic procedures,
but allow more efficient implementations.
</p>

<h2><a href="srfi-144/">SRFI 144</a>: Flonums</h2>

<p>
This SRFI describes numeric procedures applicable to <em>flonums</em>,
a subset of the inexact real numbers provided by a Scheme implementation.  In most Schemes, the flonums and the inexact reals are the same.
These procedures are semantically equivalent to the corresponding generic
procedures, but allow more efficient implementations.
</p>

<h2><a href="srfi-145/">SRFI 145</a>: Assumptions</h2>

<p>
A means to denote the invalidity of certain code paths in a Scheme
program is proposed.  It allows Scheme code to turn the evaluation
into a user-defined error that need not be signalled by the
implementation.  Optimizing compilers may use these denotations to
produce better code and to issue better warnings about dead code.
</p>

<h2><a href="srfi-146/">SRFI 146</a>: Mappings</h2>

<p>
<em>Mappings</em> are finite sets of associations, where each association
is a pair consisting of a key and an arbitrary Scheme value.  The keys
are elements of a suitable domain.  Each mapping holds no more than one
association with the same key.  The fundamental mapping operation is
retrieving the value of an association stored in the mapping when the key
is given.
</p>

<h2><a href="srfi-147/">SRFI 147</a>: Custom macro transformers</h2>

<p>
Each syntax definition assigns a macro transformer to a keyword.  The
macro transformer is specified by a transformer spec, which is either
an instance of <code>syntax-rules</code>, an existing syntactic keyword
(including macro keywords and the syntactic keywords that introduce the core forms,
like <code>lambda</code>, <code>if</code>, or <code>define</code>), or
a use of a macro that eventually expands into an instance
of <code>syntax-rules</code>.  In the latter case, the keyword of
macro use is called a <em>custom macro transformer</em>.
</p>

<h2><a href="srfi-148/">SRFI 148</a>: Eager syntax-rules</h2>

Writing powerful <code>syntax-rules</code> macros is hard because they
do not compose well: The arguments of a macro expansion are not
expanded.  This SRFI defines an easy to comprehend high-level system
for writing powerful, composable (or <em>eager</em>) macros, two of whose defining
features are that its macro arguments are (in general) eagerly expanded and that it can
be portably implemented in any Scheme implementation conforming to the
R7RS.

<h2><a href="srfi-149/">SRFI 149</a>: Basic Syntax-rules Template Extensions</h2>

<p>
The rules for valid <code>&lt;template&gt;</code>s of <code>&lt;syntax
rules&gt;</code> are slightly softened to allow for more than one
consecutive <code>&lt;ellipsis&gt;</code> in subtemplates, and to
allow pattern variables in subtemplates to be followed by more
instances of the identifier <code>&lt;ellipsis&gt;</code> than they are followed in the
subpattern in which they occur.
</p>

<h2><a href="srfi-150/">SRFI 150</a>: Hygienic ERR5RS Record Syntax (reduced)</h2>

<p>
This SRFI provides a specification and portable implementation of an
extension of the ERR5RS record syntax
of <a href="srfi-131/">SRFI
131</a>, where field names inserted by macro transformers are
effectively renamed.  This makes this SRFI compatible with the
semantics of the record-type definitions of
the <a href="http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs.pdf">R7RS</a>
as written.  In addition, field names may also be other types of
Scheme datums, like numbers and strings.
</p>

<h2><a href="srfi-151/">SRFI 151</a>: Bitwise Operations</h2>

<p>
This SRFI proposes a coherent and comprehensive set of procedures for
performing bitwise logical operations on integers; it is
accompanied by a reference implementation of the spec in terms of a set of
seven core operators. The sample implementation is portable, as efficient
as practical with pure Scheme arithmetic (it is much more efficient to replace the
core operators with C or assembly language if possible), and open source.
</p>
<p>
The precise semantics of these operators is almost never an issue. A
consistent, portable set of <em>names</em> and <em>parameter conventions</em>, however, is.
Hence this SRFI, which is based mainly on <a href="srfi-33/">SRFI 33</a>, with some changes and additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late revisions to SRFI 33</a> (which were never consummated).
<a href="srfi-60/">SRFI 60</a>
(based on SLIB) is smaller but has a few procedures of its own;
some of its procedures have both native (often Common Lisp) and SRFI 33 names.
They have been incorporated into this SRFI.
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">R6RS</a>
is a subset of SRFI 60, except that all procedure names begin with a <tt>bitwise-</tt> prefix.
A few procedures have been added from
the general vector <a href="srfi-133/">SRFI 133</a>.
</p>
<p>
Among the applications of bitwise operations are: hashing,
Galois-field calculations of error-detecting and error-correcting codes,
cryptography and ciphers,
pseudo-random number generation,
register-transfer-level modeling of digital logic designs,
Fast-Fourier transforms,
packing and unpacking numbers in persistent data structures,
space-filling curves with applications to dimension reduction
and sparse multi-dimensional database indexes,
and generating approximate seed values for root-finders
and transcendental function algorithms.
</p>
<p>
This SRFI differs from SRFI 142 in only two ways:
<ol><li><p>The <tt>bitwise-if</tt> function has the argument ordering of
SLIB, SRFI 60, and R6RS rather than the ordering of SRFI 33.</p></li>
<li><p>The order in which bits are processed by the procedures listed in the
"Bits conversion" section has been clarified
and some of the procedures' names have been changed.
See "Bit processing order" for details.
</p></li></ol>

<h2><a href="srfi-152/">SRFI 152</a>: String Library (reduced)</h2>

<p>Scheme has an impoverished set of string-processing utilities, which
is a problem for authors of portable code. This SRFI proposes a coherent
and comprehensive set of string-processing procedures.  It is a reduced
version of SRFI 13 that has been aligned with SRFI 135, Immutable Texts.
Unlike SRFI 13, it has been made consistent with the R5RS, R6RS, and
R7RS-small string procedures.  </p>

<h2><a href="srfi-153/">SRFI 153</a>: Immutable ordered sets and bags</h2>

<p><em>Isets</em> and <em>ibags</em> (also known as multisets) are immutable collections that can contain any Scheme object.  Isets enforce the constraint that no two elements can be the same in the sense of the iset's associated <em>equality predicate</em>; ibags do not. The elements in an iset or ibag appear in a fixed order determined by the comparator used to create it.

</p>

<h2><a href="srfi-154/">SRFI 154</a>: First-class dynamic environments</h2>

Scheme has the notion of the <em>dynamic extent</em> of a
    procedure call.  A number of standard Scheme procedures and
    syntaxes
    like <code>dynamic-wind</code>, <code>call-with-current-continuation</code>,
    and <code>parameterize</code>
    deal with the dynamic extent indirectly.

    This SRFI reifies the dynamic extent into a first-class value
    together with a well-defined procedural interface and a syntax to
    create procedures that remember not only the environment at
    creation time but also their dynamic environment.

<h2><a href="srfi-155/">SRFI 155</a>: Promises</h2>

<p>
Scheme, like ML, is a programming language with strict evaluation
while others, like Haskell, use lazy evaluation.  Scheme, however,
possesses the primitives <code>delay</code> and <code>force</code>
that make it possible to express lazy algorithms in the Scheme
programming language.
</p>

<p>
Lazy evaluation does not go well in conjunction with imperative,
non-functional, side effecting code.  It should, however, be
applicable in a purely functional setting.  This is the case for the
delayed evaluation model as described in the R7RS as long as no
dynamically bound variables, also known as parameter objects, are
present.  It is the purpose of this SRFI to rework the
specification in the R7RS so that lazy evaluation works with purely
functional code that makes use of dynamic environments.  This is done
by remembering the dynamic environment in effect when
the <code>delay</code> expression is evaluated.
</p>

<h2><a href="srfi-156/">SRFI 156</a>: Syntactic combiners for binary predicates</h2>

<p>The power and universality of the prefix notation employed by Scheme
  and other dialects of Lisp can be intimidating. However, we find that
  there are occasions when prefix syntax can be confusing and lead to
  code that is not self-documenting. We have identified that one of such
  cases is the use of asymmetrical binary predicates.</p>

<p>Probably the most common examples are the numerical comparison
  predicates <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>
  and <code>&gt;</code>. It is non obvious, for instance, how the expression
  <code>(&lt; a b)</code> should be pronounced.</p>

<p>The problem gets more serious in the case of user-defined binary
  predicates. For example, in the expression <code>(divides? x y)</code>
  the role of arguments is unclear: we don't know whether the author
  of the <code>divides?</code> predicate intended it to check whether
  <code>x</code> divides <code>y</code> or whether <code>y</code>
  divides <code>x</code>.</p>

<p>And while there seems to exist a silent convention among Schemers
  to interpret predicates like <code>(has-something-to? x y)</code>
  as "<code>x</code> has something to <code>y</code>", we believe
  that this convention should be made explicit, and confirmed by
  the forms available in the language.</p>

<p>We therefore propose a thin layer of "syntactic stevia" that can
  be implemented using regular Scheme macros. We suggest, that the
  code <code>(is x &lt; y)</code> should be transformed
  to <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code>
  -- to <code>(and (&lt; x y) (&lt;= y z))</code>. In addition, we
  suggest special meaning to the <code>_</code> symbol:
  <code>(is _ &lt; y)</code> and <code>(is x &lt; _)</code>
  should be transformed to <code>(lambda (_) (&lt; _ y))</code>
  and <code>(lambda (_) (&lt x _))</code>, respectively.
  This SRFI document also describes some other uses of the
  <code>is</code> macro and its limitations.</p>

</body></html>
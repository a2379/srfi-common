<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Scheme Requests for Implementation</title><link>https://srfi.schemers.org/</link><description>Updates to SRFI documents</description><language>en-US</language><webMaster>srfi@speechcode.com (Arthur A. Gleckler)</webMaster><atom:link href="https://srfi.schemers.org/rss" rel="self" type="application/rss+xml"></atom:link><item><title>SRFI 206: Auxiliary Syntax Keywords</title><link>https://srfi.schemers.org/srfi-206/srfi-206.html</link><guid>https://srfi.schemers.org/srfi-206</guid><description>SRFI 206 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>This SRFI defines a mechanism for defining auxiliary syntax
keywords independently in different modules in such a way that
they still have the same binding so that they can be used
interchangeably as literal identifiers in
<code>syntax-rules</code> and <code>syntax-case</code> expressions
and can be both imported under the same name without conflicts.</*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 21 Dec 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 209: Enums and Enum Sets</title><link>https://srfi.schemers.org/srfi-209/srfi-209.html</link><guid>https://srfi.schemers.org/srfi-209</guid><description>SRFI 209 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Enums are objects that serve to form sets of distinct classes
that specify different modes of operation for a procedure.
Their use fosters portable and readable code.</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Thu, 17 Dec 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 217: Integer Sets</title><link>https://srfi.schemers.org/srfi-217/srfi-217.html</link><guid>https://srfi.schemers.org/srfi-217</guid><description>SRFI 217 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Integer sets, or <em>isets</em>, are unordered collections of
fixnums.  (Fixnums are exact integers within certain
implementation-specified bounds.)</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Sun, 29 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 218: Unicode Numerals</title><link>https://srfi.schemers.org/srfi-218/srfi-218.html</link><guid>https://srfi.schemers.org/srfi-218</guid><description>SRFI 218 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>These procedures allow the creation and interpretation of numerals
using any set of Unicode digits that support positional notation.</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Sun, 29 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 202: Pattern-matching Variant of the and-let* Form that Supports Multiple Values</title><link>https://srfi.schemers.org/srfi-202/srfi-202.html</link><guid>https://srfi.schemers.org/srfi-202</guid><description>SRFI 202 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>The SRFI-2 library introduced the <code>and-let*</code> form
  for short-circuited evaluation in the style of the <code>and</code>
  form, with the ability to capture the (non-<code>#f</code>) results
  in the style of the <code>let*</code> form.  This document extends
  the <code>and-let*</code> form with the ability to pattern-match (or
  "destructurally bind") the values of evaluated expressions (where
  the match failure causes short-circuiting rather than raising an
  error) and the ability to handle multiple values (where only the
  falsehood of the first value causes short-circuiting).
</p></*TOP*></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Sat, 28 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 216: SICP Prerequisites (Portable)</title><link>https://srfi.schemers.org/srfi-216/srfi-216.html</link><guid>https://srfi.schemers.org/srfi-216</guid><description>SRFI 216 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
   This SRFI follows
    <a href="https://srfi.schemers.org/srfi-203/">
     SRFI 203
    </a>
   in providing "out-of-the-box" support for hosting the exercises suggested by
    <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">
     Structure and Interpretation of Computer Programs
    </a>
   in portable Scheme.
</p>

<p>
Whereas SRFI 203 focused on the necessarily non-portable aspects of the problem set (the graphics), this SRFI aims to provide support for the rest of the features, which are far more widespread, often already provided, and in reality mostly need just a common vocabulary.
</p>

<p>
This SRFI provides subroutines for working with time data, multi-threading, streams and SICP names for <code>true</code> and <code>false</code>.
</p>

<p>
None of these subroutines are fit for production use, and are only designed for pedagogical purposes.
</p>

<p>
Students, however, are expected to be able to just write</p>
 <pre>
 (include (srfi sicp))</pre>
 <p>and have the code from the book run without problems (apart from those intended by the book authors).
</p></*TOP*></blockquote></description><dc:creator>Vladimir Nikishkin</dc:creator><pubDate>Wed, 04 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 215: Central Log Exchange</title><link>https://srfi.schemers.org/srfi-215/srfi-215.html</link><guid>https://srfi.schemers.org/srfi-215</guid><description>SRFI 215 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*>    <p>
      This SRFI specifies a central log exchange for Scheme that
      connects log producers with log consumers. It allows multiple
      logging systems to interoperate and co-exist in the same
      program. Library code can produce log messages without knowledge
      of which log system is actually used. Simple applications can
      easily get logs on standard output, while more advanced
      applications can send them to a full logging system.
    </p></*TOP*></blockquote></description><dc:creator>Göran Weinholt</dc:creator><pubDate>Tue, 03 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 207: String-notated bytevectors</title><link>https://srfi.schemers.org/srfi-207/srfi-207.html</link><guid>https://srfi.schemers.org/srfi-207</guid><description>SRFI 207 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>To ease the human reading and writing of Scheme code involving
binary data that for mnemonic reasons corresponds
as a whole or in part to ASCII-coded text, a notation
for bytevectors is defined which allows printable ASCII characters
to be used literally without being converted to their corresponding
integer forms. In addition, this SRFI provides a set of procedures
known as the bytestring library
for constructing a bytevector from a sequence of integers,
characters, strings, and/or bytevectors, and for manipulating
bytevectors as if they were strings as far as possible.</p></*TOP*></blockquote></description><dc:creator>Daphne Preston-Kendal (external notation), John Cowan (procedure design), and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Thu, 29 Oct 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 170: POSIX API</title><link>https://srfi.schemers.org/srfi-170/srfi-170.html</link><guid>https://srfi.schemers.org/srfi-170</guid><description>SRFI 170 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system on top of
which a Scheme program is executing. This SRFI specifies some of the ways the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all of the
functions of this SRFI are available on all operating systems.
</p></*TOP*></blockquote></description><dc:creator>Olin Shivers (original author), John Cowan (editor and shepherd), and Harold Ancell (implementer and editor)</dc:creator><pubDate>Wed, 28 Oct 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 214: Flexvectors</title><link>https://srfi.schemers.org/srfi-214/srfi-214.html</link><guid>https://srfi.schemers.org/srfi-214</guid><description>SRFI 214 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>A <em>flexvector</em>, also known as a dynamic array or an arraylist, is a mutable vector-like data structure with an adjustable size. Flexvectors allow O(1) random access, O(1) insertion/removal at the end, and O(n) insertion/removal elsewhere. This SRFI defines a suite of operations on flexvectors, modeled after <a href="https://srfi.schemers.org/srfi-133/srfi-133.html">SRFI 133</a>'s vector operations.</p></*TOP*></blockquote></description><dc:creator>Adam Nelson</dc:creator><pubDate>Wed, 07 Oct 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 213: Identifier Properties</title><link>https://srfi.schemers.org/srfi-213/srfi-213.html</link><guid>https://srfi.schemers.org/srfi-213</guid><description>SRFI 213 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Using the <code>define-property</code> definition described in
  this SRFI, expand-time properties can be associated with
  identifiers in a referentially transparent and lexically scoped way.</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 29 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 212: Aliases</title><link>https://srfi.schemers.org/srfi-212/srfi-212.html</link><guid>https://srfi.schemers.org/srfi-212</guid><description>SRFI 212 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI introduces <em>alias definitions</em>, a syntactic
extension.  An alias definition transfers the binding of one
identifier to another, effectively aliasing the identifier.</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 22 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 196: Range Objects</title><link>https://srfi.schemers.org/srfi-196/srfi-196.html</link><guid>https://srfi.schemers.org/srfi-196</guid><description>SRFI 196 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Ranges are collections somewhat similar to vectors, except that
  they are immutable and have algorithmic representations instead of
  the uniform per-element data structure of vectors. The storage required is
  usually less than the size of the same collection stored in a
  vector and the time needed to reference a particular element is
  typically less for a range than for the same collection stored in a
  list. This SRFI defines a large subset of the sequence operations
  defined on lists, vectors, strings, and other collections.  If
  necessary, a range can be converted to a list, vector, or string of
  its elements or a generator that will lazily produce each element in
  the range.</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</dc:creator><pubDate>Thu, 17 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 203: A Simple Picture Language in the Style of SICP</title><link>https://srfi.schemers.org/srfi-203/srfi-203.html</link><guid>https://srfi.schemers.org/srfi-203</guid><description>SRFI 203 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI proposes a simple library for programmatic drawing of
pictures compatible with Section 2.2.4 of <cite>Structure and
Interpretation of Computer Programs</cite>.</p>

<p>It aims to close the gap between the Scheme suggested for study in
the book and portable Scheme.</p></*TOP*></blockquote></description><dc:creator>Vladimir Nikishkin</dc:creator><pubDate>Thu, 17 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 197: Pipeline Operators</title><link>https://srfi.schemers.org/srfi-197/srfi-197.html</link><guid>https://srfi.schemers.org/srfi-197</guid><description>SRFI 197 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Many functional languages provide pipeline operators, like Clojure's <code>-></code> or OCaml's <code>|></code>. Pipelines are a simple, terse, and readable way to write deeply-nested expressions. This SRFI defines a family of <code>chain</code> and <code>nest</code> pipeline operators, which can rewrite nested expressions like <code>(a b (c d (e f g)))</code> as a sequence of operations: <code>(chain g (e f _) (c d _) (a b _))</code>.</p></*TOP*></blockquote></description><dc:creator>Adam Nelson</dc:creator><pubDate>Sat, 12 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 198: Foreign Interface Status</title><link>https://srfi.schemers.org/srfi-198/srfi-198.html</link><guid>https://srfi.schemers.org/srfi-198</guid><description>SRFI 198 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
This SRFI provides means to construct, return or signal, and extract
information from Scheme interfaces with "foreign" systems such as the
P<small>OSIX</small> API, databases, and libraries.
</p></*TOP*></blockquote></description><dc:creator>John Cowan (editor and shepherd), Harold Ancell (implementer and editor), and Lassi Kortela (architect)</dc:creator><pubDate>Sat, 12 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 211: Scheme Macro Libraries</title><link>https://srfi.schemers.org/srfi-211/srfi-211.html</link><guid>https://srfi.schemers.org/srfi-211</guid><description>SRFI 211 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines library name spaces where common extensions
  of the <code>syntax-rules</code> macro facility can be located
  and which can be tested against in <code>cond-expand</code> forms.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 12 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 193: Command line</title><link>https://srfi.schemers.org/srfi-193/srfi-193.html</link><guid>https://srfi.schemers.org/srfi-193</guid><description>SRFI 193 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>R<sup>6</sup>RS and R<sup>7</sup>RS define a
<code>command-line</code> procedure. While a useful baseline, the
specification is not detailed enough to cover all practical
situations. This SRFI clarifies the definition of
<code>command-line</code> and adds a few related procedures.
Scheme scripts, standalone executables, compilation and REPL use
are accounted for. Option parsing is out of scope.</p></*TOP*></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Thu, 10 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 181: Custom ports (including transcoded ports)</title><link>https://srfi.schemers.org/srfi-181/srfi-181.html</link><guid>https://srfi.schemers.org/srfi-181</guid><description>SRFI 181 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI is derived from parts of
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-1.html#node_toc_node_sec_8.2.4">
library section 8.2.4</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.7">
library section 8.2.7</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.10">
library section 8.2.10</a>, and
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.13">
library section 8.2.13</a>
of the R6RS.
These sections are themselves based on parts of
<a href="http://srfi.schemers.org/srfi-79/srfi-79.html">SRFI 79</a>,
<a href="http://srfi.schemers.org/srfi-80/srfi-80.html">SRFI 80</a> and
<a href="http://srfi.schemers.org/srfi-81/srfi-81.html">SRFI 81</a>.
These procedures provide a hook into the Scheme port system from below, allowing the
creation of custom ports that behave as much as possible like the standard
file, string, and bytevector ports, but that call a procedure to produce
data to input ports or to consume data from output ports.
Procedures for creating ports that transcode
between bytes and characters are an important special
case and are also documented in this SRFI.
</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 08 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 186: Transcoders and transcoded ports</title><link>https://srfi.schemers.org/srfi-186/srfi-186.html</link><guid>https://srfi.schemers.org/srfi-186</guid><description>SRFI 186 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This is an extract from the R6RS that documents its support for
transcoders and transcoded ports.  These provide a hook into the
Scheme port system from below, allowing the creation of textual ports
that provide non-default encoding and decoding from arbitrary binary
ports.  It has been lightly edited to fit R7RS style.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 08 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 210: Procedures and Syntax for Multiple Values</title><link>https://srfi.schemers.org/srfi-210/srfi-210.html</link><guid>https://srfi.schemers.org/srfi-210</guid><description>SRFI 210 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
  This SRFI extends the Scheme standard with a number of
  procedures and syntax dealing with multiple values, including
  syntax to create lists and vectors from expressions returning
  multiple values and procedures returning the elements of a list
  or vector as multiple values.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 29 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 195: Multiple-value boxes</title><link>https://srfi.schemers.org/srfi-195/srfi-195.html</link><guid>https://srfi.schemers.org/srfi-195</guid><description>SRFI 195 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
  This SRFI extends the specification of the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
  111</a> so that they are multiple-values aware.  Whereas a SRFI
  111 box is limited in that it can only box a single value,
  multiple values can be boxed with this SRFI.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 28 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 208: NaN procedures</title><link>https://srfi.schemers.org/srfi-208/srfi-208.html</link><guid>https://srfi.schemers.org/srfi-208</guid><description>SRFI 208 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI provides procedures that dissect NaN (Not a Number) inexact values.</p></*TOP*></blockquote></description><dc:creator>Emmanuel Medernach (design), John Cowan (editor), and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Fri, 28 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 194: Random data generators</title><link>https://srfi.schemers.org/srfi-194/srfi-194.html</link><guid>https://srfi.schemers.org/srfi-194</guid><description>SRFI 194 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines a set of
<a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI 158</a>
generators and generator makers that yield random data of specific
ranges and distributions.  It is intended to be implemented on top of
<a href="https://srfi.schemers.org/srfi-27/srfi-27.html">SRFI 27</a>,
which provides the underlying source of random integers and floats.</p></*TOP*></blockquote></description><dc:creator>Shiro Kawai (design), Arvydas Silanskas (implementation), John Cowan (editor and shepherd), and Linas Vepštas (implementation)</dc:creator><pubDate>Wed, 26 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 178: Bitvector library</title><link>https://srfi.schemers.org/srfi-178/srfi-178.html</link><guid>https://srfi.schemers.org/srfi-178</guid><description>SRFI 178 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI describes a set of operations on
homogeneous bitvectors.
Operations analogous to those provided on the other homogeneous
vector types described in
<a href="https://srfi.schemers.org/srfi-160/srfi-160.html">SRFI 160</a>
are provided,
along with operations analogous to the bitwise operations of
<a href="https://srfi.schemers.org/srfi-151/srfi-151.html">SRFI 151</a>.</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Tue, 25 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 159: Combinator Formatting</title><link>https://srfi.schemers.org/srfi-159/srfi-159.html</link><guid>https://srfi.schemers.org/srfi-159</guid><description>SRFI 159 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p></*TOP*></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 177: Portable keyword arguments</title><link>https://srfi.schemers.org/srfi-177/srfi-177.html</link><guid>https://srfi.schemers.org/srfi-177</guid><description>SRFI 177 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Many Scheme implementations have keyword arguments, but they
have not been widely standardized. This SRFI defines the macros
<code>lambda/kw</code> and <code>call/kw</code>. They can be used
identically in every major implementation currently in use,
making it safe to use keyword arguments in portable code. The
macros expand to native keyword arguments in Schemes that have
them, letting programmers mix portable code and
implementation-specific code.</p></*TOP*></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 192: Port Positioning</title><link>https://srfi.schemers.org/srfi-192/srfi-192.html</link><guid>https://srfi.schemers.org/srfi-192</guid><description>SRFI 192 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This is an extract from the R6RS that documents its support for
positioning ports.  Binary ports can be positioned to read or write
at a specific byte; textual ports at a specific character,
although character positions can't be synthesized portably.
It has been lightly edited to fit R7RS style.</p></*TOP*></blockquote></description><dc:creator>John Cowan and Shiro Kawai (implementation; requires a hook)</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 166: Monadic Formatting</title><link>https://srfi.schemers.org/srfi-166/srfi-166.html</link><guid>https://srfi.schemers.org/srfi-166</guid><description>SRFI 166 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
  A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p>

<p>
  This SRFI is an updated version of SRFI 159, primarily with the
  difference that state variables are hygienic.</p>

<p>
Summary of differences from SRFI 159:
<ul>
  <li>State variables are first class and hygienic</li>
  <li>Added <code>written-shared</code>, <code>pretty-shared</code></li>
  <li>Added <code>as-italic</code>, <code>as-color</code>, <code>as-true-color</code>, <code>on-<i>color</i></code> background variants, and <code>pretty-with-color</code></li>
  <li>Added <code>ambiguous-is-wide?</code> state variable and <code>string-terminal-width/wide</code> utility</li>
  <li>Added <code>substring/width</code> state var for width-aware substring operations, with <code>substring-terminal-width(/wide)</code> utilities</li>
  <li>Added <code>substring/preserve</code> state var used in trimming, with <code>substring-terminal-preserve</code> utility</li>
  <li>Added <code>pretty-environment</code> state variable</li>
  <li>Renamed <code>as-unicode</code> to <code>terminal-aware</code></li>
  <li>Restored non-uniform comma rules as needed in India</li>
  <li>Restored <code>upcased</code> and <code>downcased</code></li>
  <li>Several clarifications and more examples</li>
</ul></p></*TOP*></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Thu, 30 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 205: POSIX Terminal Fundamentals</title><link>https://srfi.schemers.org/srfi-205/srfi-205.html</link><guid>https://srfi.schemers.org/srfi-205</guid><description>SRFI 205 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
This SRFI describes procedures for command-line and terminal interface
programs to safely change and reset terminal modes, for example from
cooked to raw and back, and for serial-line device manipulation for
interfacing with embedded hardware and the like.
</p>
<p>
It is intended to provide all the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html">termios structure</a>
functionality a modern Scheme programmer might desire by supplying a
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/stty.html">stty</a>
procedure, and simple abstractions on top of it.
</p>
</*TOP*></blockquote></description><dc:creator>John Cowan (author) and Harold Ancell (author and editor)</dc:creator><pubDate>Thu, 23 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 199: POSIX errno manipulation</title><link>https://srfi.schemers.org/srfi-199/srfi-199.html</link><guid>https://srfi.schemers.org/srfi-199</guid><description>SRFI 199 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>The majority of P<small>OSIX</small> system and library calls
  require accessing <code>errno</code> to discern the specific cause
  of an error, and some require setting it to 0 before being called.
  This SRFI specifies procedures to both retrieve its value, and to
  set it.
</p></*TOP*></blockquote></description><dc:creator>Harold Ancell</dc:creator><pubDate>Sun, 19 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 204: Wright-Cartwright-Shinn Pattern Matcher</title><link>https://srfi.schemers.org/srfi-204/srfi-204.html</link><guid>https://srfi.schemers.org/srfi-204</guid><description>SRFI 204 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Pattern matching decomposes a compound data structure
into parts and assigns those parts to variables. This
SRFI describes a pattern-matching library already in use by
several scheme implementations which can match many common
compound data structures.</p></*TOP*></blockquote></description><dc:creator>Felix Thibault</dc:creator><pubDate>Wed, 15 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 189: Maybe and Either: optional container types</title><link>https://srfi.schemers.org/srfi-189/srfi-189.html</link><guid>https://srfi.schemers.org/srfi-189</guid><description>SRFI 189 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines two disjoint immutable container types
known as Maybe and Either,
both of which can contain objects collectively known as their payload.
A Maybe object is either a Just object or the unique object Nothing
(which has no payload); an Either object is either
a Right object or a Left object.  Maybe represents the concept of
optional values; Either represents the concept of values which are
either correct (Right) or errors (Left).</p>
<p>Note that the terms Maybe, Just, Nothing, Either, Right, and Left
are capitalized in this SRFI so as not to be confused with their
ordinary use as English words.  Thus "returns Nothing" means
"returns the unique Nothing object"; "returns nothing" could be
interpreted as "returns no values"
or "returns an unspecified value".</p></*TOP*></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</dc:creator><pubDate>Tue, 14 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 191: Procedure Arity Inspection</title><link>https://srfi.schemers.org/srfi-191/srfi-191.html</link><guid>https://srfi.schemers.org/srfi-191</guid><description>SRFI 191 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Many Scheme systems provide mechanisms for inspecting the arity of a
procedural value, making it a common feature, however there is no
standard interface.  As a result there is no portable way to observe
the arity of a procedure without actually applying it.  This
SRFI proposes a simple interface that is consistent with existing
Scheme systems' facilities and prior proposals.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 05 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 180: JSON</title><link>https://srfi.schemers.org/srfi-180/srfi-180.html</link><guid>https://srfi.schemers.org/srfi-180</guid><description>SRFI 180 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This library describes a JavaScript Object Notation (JSON) parser and printer.  It supports JSON that may be bigger than memory.</p></*TOP*></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Wed, 01 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 179: Nonempty Intervals and Generalized Arrays (Updated)</title><link>https://srfi.schemers.org/srfi-179/srfi-179.html</link><guid>https://srfi.schemers.org/srfi-179</guid><description>SRFI 179 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general; at their most basic, an array is simply a mapping, or function, from multi-indices of exact integers $i_0,\ldots,i_{d-1}$ to Scheme values.  The set of multi-indices $i_0,\ldots,i_{d-1}$ that are valid for a given array form the <i>domain</i> of the array.  In this SRFI, each array's domain consists  of the cross product of nonempty intervals of exact integers $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$ of $\mathbb Z^d$, $d$-tuples of integers.  Thus, we introduce a data type called $d$-<i>intervals</i>, or more briefly <i>intervals</i>, that encapsulates this notion. (We borrow this terminology from, e.g.,  Elias Zakon's <a href="http://www.trillia.com/zakon1.html">Basic Concepts of Mathematics</a>.) Specialized variants of arrays are specified to provide portable programs with efficient representations for common use cases.</p></*TOP*></blockquote></description><dc:creator>Bradley J. Lucier</dc:creator><pubDate>Tue, 30 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 200: Pattern Matching</title><link>https://srfi.schemers.org/srfi-200/srfi-200.html</link><guid>https://srfi.schemers.org/srfi-200</guid><description>SRFI 200 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI discusses the most widespread existing pattern matching libraries
  for the Scheme programming language - namely, the pattern matcher
  presented by Andrew K. Wright and Robert Cartwright in the paper "A Soft
  Type System for Scheme", the pattern matcher developed by Dan Friedman,
  Erik Hilsdale and Kent Dybvig, and the <code>racket/match</code> module
  distributed with the Racket programming environment.
  It then extracts a pattern syntax which is compatible with two of
  those implementations and provides extrinsic rationale for that syntax.
  It also provides a simple implementation of a pattern matcher
  which conforms to the specification of a pattern language provided
  in this document.</p></*TOP*></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Thu, 25 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 201: Syntactic Extensions to the Core Scheme Bindings</title><link>https://srfi.schemers.org/srfi-201/srfi-201.html</link><guid>https://srfi.schemers.org/srfi-201</guid><description>SRFI 201 is now in <em>draft</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This document describes a handful of syntactic extensions
  to the core bindings of the Scheme programming language.
  In particular, it proposes to extend the binding forms
  <code>lambda</code>, <code>let</code>,
  <code>let*</code> with pattern matching capabilities, to extend the forms <code>let*</code>
  and <code>or</code> with the ability
  to handle multiple values, and to extend the form <code>define</code> with
  the ability of defining "curried" functions.</p></*TOP*></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Thu, 25 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 190: Coroutine Generators</title><link>https://srfi.schemers.org/srfi-190/srfi-190.html</link><guid>https://srfi.schemers.org/srfi-190</guid><description>SRFI 190 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines syntax to create
  <a href="https://srfi.schemers.org/srfi-121/">SRFI
    121</a>/<a href="https://srfi.schemers.org/srfi-158/">158</a>
  coroutine generators conveniently and in the flavor of Python
  generator functions.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 11 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 188: Splicing binding constructs for syntactic keywords</title><link>https://srfi.schemers.org/srfi-188/srfi-188.html</link><guid>https://srfi.schemers.org/srfi-188</guid><description>SRFI 188 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Splicing binding constructs for syntactic keywords are versions
  of <code>let-syntax</code> and <code>letrec-syntax</code> that can
  be used in a definition context in the same way
  as <code>begin</code>.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Wed, 03 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 185: Linear adjustable-length strings</title><link>https://srfi.schemers.org/srfi-185/srfi-185.html</link><guid>https://srfi.schemers.org/srfi-185</guid><description>SRFI 185 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
Scheme specifies mutable fixed-length strings.
<a href="https://srfi.schemers.org/srfi-118/srfi-118.html">SRFI 118</a>
adds two procedures, <code>string-append!</code> and
<code>string-replace!</code>, which allow the length of the string to change.
This SRFI provides two linear-update versions of these procedures:
that is, the implementation may change the string length or return a
new string instead.
In addition, two convenience macros are provided that make the
procedures somewhat easier to use.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 26 Apr 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 182: ADBMAL, ALET, and ALET*</title><link>https://srfi.schemers.org/srfi-182/srfi-182.html</link><guid>https://srfi.schemers.org/srfi-182</guid><description>SRFI 182 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Unlike the VALUES and CALL-WITH-VALUES mechanism of R5RS, this one
uses an explicit representation for multiple return values as a single
value, namely a procedure.  Decomposition of multiple values is done
by simple application.  The macro, ADBMAL, evaluates to a procedure
that takes one procedure argument.  The ADBMAL macro can be compared
with LAMBDA.  While a LAMBDA expression that consists of
&lt;formals> and &lt;body> requires some actual arguments later
when the evaluated LAMBDA expression is called, an ADBMAL expression
that consists of &lt;expression>s corresponding to actual arguments
of LAMBDA requires &lt;formals> and &lt;body>, that is, an
evaluated LAMBDA expression, later when the evaluated ADBMAL
expression is called.</p>

<p>This SRFI also introduces the new LET-syntax ALET and ALET*, which
depend on ADBMAL to manipulate multiple values, and which are
compatible with LET and LET* of R5RS in single-value bindings.  They
also have a binding form making use of VALUES and CALL-WITH-VALUES to
handle multiple values, and new binding forms for list, cons, and
other multiple values.  In addition, they have several new binding
forms for useful functions such as escape, iteration, optional
arguments, etc.</p></*TOP*></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 183: Another format procedure, Fox</title><link>https://srfi.schemers.org/srfi-183/srfi-183.html</link><guid>https://srfi.schemers.org/srfi-183</guid><description>SRFI 183 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI introduces the formatting procedure Fox ("format of X"),
  which takes one required argument and a variable number of additional
  arguments and returns a formatted string.</p></*TOP*></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 184: define-record-lambda</title><link>https://srfi.schemers.org/srfi-184/srfi-184.html</link><guid>https://srfi.schemers.org/srfi-184</guid><description>SRFI 184 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI introduces a macro, DEFINE-RECORD-LAMBDA, that defines a
  set of procedures, that is, a group of constructors and a predicate.
  The constructors also make a group of procedures, namely record
  lambdas, that have no explicit field accessors and mutators.  They
  can have various kinds of fields, such as common fields, required
  fields, optional fields, automatic fields, read-only fields,
  read-write fields, invisible fields, immutable fields, and virtual
  fields.</p></*TOP*></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 187: ALAMBDA and ADEFINE</title><link>https://srfi.schemers.org/srfi-187/srfi-187.html</link><guid>https://srfi.schemers.org/srfi-187</guid><description>SRFI 187 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI introduces alambda, which creates a procedure that checks
its actual arguments, takes various types of required and optional
variables.<br></br> This SRFI is based on
<a href="https://srfi.schemers.org/srfi-92/">SRFI 92</a>
as an extension of the optional arguments of
<a href="https://srfi.schemers.org/srfi-182/">SRFI 182</a>.</p></*TOP*></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 176: Version flag</title><link>https://srfi.schemers.org/srfi-176/srfi-176.html</link><guid>https://srfi.schemers.org/srfi-176</guid><description>SRFI 176 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines a standard command-line flag to get version
  information from a Scheme implementation.  The output is
  Line-oriented S-expressions which are easy to parse from Scheme, C,
  and shell scripts and can co-exist with non-S-expression output.  A
  standard vocabulary is defined; extensions are easy to make.</p></*TOP*></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Mon, 24 Feb 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 174: POSIX Timespecs</title><link>https://srfi.schemers.org/srfi-174/srfi-174.html</link><guid>https://srfi.schemers.org/srfi-174</guid><description>SRFI 174 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines the trivial type <i>timespec</i>, which is used
to represent the <code>struct timespec</code> defined by the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html">
P<small>OSIX</small> <code>&lt;time.h></code> header</a>.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sat, 21 Dec 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 175: ASCII character library</title><link>https://srfi.schemers.org/srfi-175/srfi-175.html</link><guid>https://srfi.schemers.org/srfi-175</guid><description>SRFI 175 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>  <p>This SRFI defines ASCII-only equivalents to many of the
  character procedures in standard Scheme plus a few extra ones.
  Recent Scheme standards are based around Unicode but the
  significant syntactic elements in many file formats and network
  protocols are all ASCII. Such low-level code can run faster and
  its behavior can be easier to understand when it uses ASCII
  primitives.</p></*TOP*></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 20 Dec 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 172: Two Safer Subsets of R7RS</title><link>https://srfi.schemers.org/srfi-172/srfi-172.html</link><guid>https://srfi.schemers.org/srfi-172</guid><description>SRFI 172 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI provides two libraries for use with R7RS that provide a
way to sandbox the <code>eval</code> procedure to make it safer to use
in evaluating Scheme expressions of doubtful provenance.  The intention
is to call <code>eval</code>, passing it an S-expression representing a
Scheme procedure and the environment defined by one of these libraries.
Since code evaluated by <code>eval</code> runs in a null lexical
environment, the resulting procedure can then be invoked with less
concern about possible side effects.
</p>

<p><b>Use of these libraries does not provide any sort of safety
guarantee.  There are still many loopholes uncaught, including
attempts to process circular structure and over-allocation of memory.
The claim is only that the probability of such an attack is reduced,
not that it is eliminated.
However, using these libraries is a simple provision that is easy to
implement and easy to use.  For higher safety, it can readily be
combined with other provisions.
</b></p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 10 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 167: Ordered Key Value Store</title><link>https://srfi.schemers.org/srfi-167/srfi-167.html</link><guid>https://srfi.schemers.org/srfi-167</guid><description>SRFI 167 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This library describes an interface for an ordered key-value store
  that is suitable for implementing a storage engine for the generic
  tuple-store SRFI.  It maps cleanly to existing ordered key-value
  databases that may or may not provide transactions.</p></*TOP*></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Fri, 08 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 168: Generic Tuple Store Database</title><link>https://srfi.schemers.org/srfi-168/srfi-168.html</link><guid>https://srfi.schemers.org/srfi-168</guid><description>SRFI 168 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This library is a generic approach to the database abstractions
  known as triplestore and quadstore.  Generic Tuple Store Database
  implements n-tuple ordered sets and associated primitives for
  working with them in the context of data management.</p></*TOP*></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Fri, 08 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 171: Transducers</title><link>https://srfi.schemers.org/srfi-171/srfi-171.html</link><guid>https://srfi.schemers.org/srfi-171</guid><description>SRFI 171 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>A library implementing transducers &amp;mdash; composable algorithmic
  transformations.  Scheme has many different ways of expressing
  transformations over different collection types, but they are all
  unique to whatever base type they work on.  This SRFI proposes a new
  construct, the transducer, that is oblivious to the context in which
  it is being used.</p></*TOP*></blockquote></description><dc:creator>Linus Björnstam</dc:creator><pubDate>Sat, 26 Oct 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 173: Hooks</title><link>https://srfi.schemers.org/srfi-173/srfi-173.html</link><guid>https://srfi.schemers.org/srfi-173</guid><description>SRFI 173 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This library describes a mechanism known as hooks.  Hooks are a
  certain kind of extension point in a program that allows
  interleaving the execution of arbitrary code with the execution of
  the program without introducing any coupling between the two.</p></*TOP*></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Thu, 24 Oct 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 165: The Environment Monad</title><link>https://srfi.schemers.org/srfi-165/srfi-165.html</link><guid>https://srfi.schemers.org/srfi-165</guid><description>SRFI 165 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>Monads model computations.  The environment monad models
computations that depend on values from a shared environment.
These computations can read values from the environment, pass
values to subsequent computations, execute sub-computations in an
extended environment, and modify the environment for future
computations.</*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 05 Sep 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 160: Homogeneous numeric vector libraries</title><link>https://srfi.schemers.org/srfi-160/srfi-160.html</link><guid>https://srfi.schemers.org/srfi-160</guid><description>SRFI 160 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI describes a set of operations on SRFI 4 homogeneous vector
types (plus a few additional types) that are closely analogous
to the vector operations library,
<a href="http://srfi.schemers.org/srfi-133/srfi-133.html">
SRFI 133</a>.
An external representation is specified which may be supported by the
<code>read</code> and <code>write</code> procedures and by the program
parser so that programs can contain references to literal homogeneous
vectors.</p></*TOP*></blockquote></description><dc:creator>John Cowan and Shiro Kawai (contributed a major patch)</dc:creator><pubDate>Tue, 27 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 162: Comparators sublibrary</title><link>https://srfi.schemers.org/srfi-162/srfi-162.html</link><guid>https://srfi.schemers.org/srfi-162</guid><description>SRFI 162 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
This SRFI provides a few extra procedures and comparators to go
with SRFI 128, Comparators.  Implementers are urged to add them to
their SRFI 128 libraries, for which reason they are not packaged
as a separate library.
</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 27 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 164: Enhanced multi-dimensional Arrays</title><link>https://srfi.schemers.org/srfi-164/srfi-164.html</link><guid>https://srfi.schemers.org/srfi-164</guid><description>SRFI 164 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI describes the array data type (a generalization of
  vectors to multiple indexes or dimensions), along with a set of
  procedures for working on them.</p>
<p>This specification is an extension of <a href="http://srfi.schemers.org/srfi-25/srfi-25.html">SRFI 25</a>,
  with additions from Racket’s
  <a href="https://docs.racket-lang.org/math/array.html">math.array</a> package
  and other sources.  It has been implemented in the <a href="https://www.gnu.org/software/kawa/Arrays.html">Kawa dialect of Scheme</a>.</p></*TOP*></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Thu, 08 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 169: Underscores in numbers</title><link>https://srfi.schemers.org/srfi-169/srfi-169.html</link><guid>https://srfi.schemers.org/srfi-169</guid><description>SRFI 169 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Many people find that large numbers are easier to read when the
  digits are broken into small groups.  For example, the number
  <code>1582439</code> might be easier to read if written as <code>1
  582 439</code>.  This applies to source code as it does to other
  writing.  We propose an extension of Scheme syntax to allow the
  underscore as a digit separator in numerical constants.</p></*TOP*></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 26 Jul 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 121: Generators</title><link>https://srfi.schemers.org/srfi-121/srfi-121.html</link><guid>https://srfi.schemers.org/srfi-121</guid><description>SRFI 121 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*>      <p>This SRFI defines utility procedures that
      create, transform, and consume generators. A generator is simply a
      procedure with no arguments that works as a source of a series of values.
      Every time it is called, it yields a value. Generators may be finite or
      infinite; a finite generator returns an end-of-file object to indicate
      that it is exhausted. For example, <code>read-char</code>,
      <code>read-line</code>, and <code>read</code> are generators that
      generate characters, lines, and objects from the current input port.
      Generators provide lightweight laziness.</p></*TOP*></blockquote></description><dc:creator>Shiro Kawai, John Cowan, and Thomas Gilray</dc:creator><pubDate>Thu, 18 Jul 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 161: Unifiable Boxes</title><link>https://srfi.schemers.org/srfi-161/srfi-161.html</link><guid>https://srfi.schemers.org/srfi-161</guid><description>SRFI 161 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
  Unifiable boxes are, like the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
    111</a>, objects with a single mutable state.  A constructor,
  predicate, accessor, and mutator are provided.
</p>

<p>
In addition to this, an equality predicate and union operations (link,
union, unify) are provided.  Applying a union operation to two
unifiable boxes makes the two boxes equal (in the sense of the
equality predicate).  As a consequence, their state will also become
identical.  In the case of link and union, it will be the state of one
of the two unioned boxes.  In the case of unify, the state is
determined by a supplied unification procedure.
</p>

<p>
  Unifiable boxes are
  also known under the names <i>disjoint-set data
    structure</i>, <i>union–find data structure</i> or <i>merge–find
    set</i>.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 08 Feb 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 163: Enhanced array literals</title><link>https://srfi.schemers.org/srfi-163/srfi-163.html</link><guid>https://srfi.schemers.org/srfi-163</guid><description>SRFI 163 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This is a specification of a reader form (literals)
for multi-dimensional arrays.
It is an extension of the Common Lisp array reader syntax to handle
non-zero lower bounds, optional explicit bounds,
and optional uniform element types (compatible with <a href="https://srfi.schemers.org/srfi-4">SRFI 4</a>).
It can be used in conjunction with <a href="https://srfi.schemers.org/srfi-25">SRFI 25</a>, <a href="https://srfi.schemers.org/srfi-122">SRFI 122</a>,
or  <a href="https://srfi.schemers.org/srfi-164">SRFI 164</a>.
These extensions were implemented in Guile (except the handling of rank-0 arrays),
and later in Kawa.
</p><p>There are recommendations for output formatting
and a suggested <code>format-array</code> procedure.</p></*TOP*></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Fri, 18 Jan 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 154: First-class dynamic extents</title><link>https://srfi.schemers.org/srfi-154/srfi-154.html</link><guid>https://srfi.schemers.org/srfi-154</guid><description>SRFI 154 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Scheme has the notion of the <em>dynamic extent</em> of a
  procedure call.  A number of standard Scheme procedures and
  syntaxes
  like <code>dynamic-wind</code>, <code>call-with-current-continuation</code>,
  and <code>parameterize</code>
  deal with the dynamic extent indirectly.  The same holds true
  for the procedures and syntaxes dealing with continuation
  marks as defined by <a href="https://srfi.schemers.org/srfi-157/srfi-157.html">SRFI
  157</a>.</p>

<p>This SRFI reifies the dynamic extent into a first-class value
  together with a well-defined procedural interface and a syntax to
  create procedures that remember not only their environment at
  creation time but also their dynamic extent, which includes their
  dynamic environment.</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 15 Sep 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 155: Promises</title><link>https://srfi.schemers.org/srfi-155/srfi-155.html</link><guid>https://srfi.schemers.org/srfi-155</guid><description>SRFI 155 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>	<p>
	  Scheme, like ML, is a programming language with strict evaluation
	  while others, like Haskell, use lazy evaluation.  Scheme, however,
	  possesses the primitives <code>delay</code> and <code>force</code>
	  that make it possible to express lazy algorithms.

	</p><p>
	  Lazy evaluation does not go well in conjunction with imperative,
	  non-functional, side-effecting code.  It should, however, be
	  applicable in a purely functional setting.  This is the case for the
	  delayed evaluation model as described in the R7RS as long as no
	  dynamically bound variables, also known as parameter objects, are
	  present.  It is the purpose of this SRFI to rework the specification
	  in the R7RS so that lazy evaluation works with purely functional code
	  that makes use of dynamic environments or, more generally, the dynamic
	  extent.  This is done by remembering the dynamic extent in effect when
	  the <code>delay</code> expression is evaluated.

	</p><p>
	  Another perceived misfeature of the R7RS model of delayed evaluation
	  is the apparent need of the <code>delay-force</code> special form to
	  express iterative lazy algorithms.  It is shown that
	  the <code>delay-force</code> special form is unneeded and that the
	  implementation can (and should) handle iterative lazy algorithms
	  without space leaks.</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 15 Sep 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 153: Ordered Sets</title><link>https://srfi.schemers.org/srfi-153/srfi-153.html</link><guid>https://srfi.schemers.org/srfi-153</guid><description>SRFI 153 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*><p><em>Osets</em> are immutable collections that can contain any Scheme
  object. Osets enforce the constraint that no two elements can be the same
  in the sense of the oset's associated <em>equality predicate</em>
  The elements in an oset appear in a fixed order determined by the
  comparator used to create it.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 08 Jul 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 146: Mappings</title><link>https://srfi.schemers.org/srfi-146/srfi-146.html</link><guid>https://srfi.schemers.org/srfi-146</guid><description>SRFI 146 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>      <p><em>Mappings</em> are finite sets of
      associations, where each association is a pair consisting of a key and an
      arbitrary Scheme value. The keys are elements of a suitable domain. Each
      mapping holds no more than one association with the same key. The
      fundamental mapping operation is retrieving the value of an association
      stored in the mapping when the key is given.</p></*TOP*></blockquote></description><dc:creator>Arthur A. Gleckler and Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 24 May 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 157: Continuation marks</title><link>https://srfi.schemers.org/srfi-157/srfi-157.html</link><guid>https://srfi.schemers.org/srfi-157</guid><description>SRFI 157 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>
  Continuation marks are a programming language feature that allows
  one to attach information to and retrieve information from
  continuations, generalizing stack inspection.  Conceptually, a
  continuation consists of a number of frames where each frame stands
  for an active procedure call that is not a tail call.  A
  continuation mark is then a key-value pair associated with a frame,
  with keys compared using <code>eq?</code>.
  At most one mark for a given key can be attached to a single frame.
</p>

<p>
  Besides stack inspection, continuation marks can be used to
  implement dynamic scope, delimited continuations, or delayed
  evaluation that is able to handle iterative lazy algorithms.
</p>
<p>
  This SRFI proposes to add continuation marks to the Scheme
  programming language.  The interface defined here is modelled after
  Racket's continuation marks.  It does not include all forms and
  procedures provided by Racket but provides a compatible subset.
</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 29 Jan 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 150: Hygienic ERR5RS Record Syntax (reduced)</title><link>https://srfi.schemers.org/srfi-150/srfi-150.html</link><guid>https://srfi.schemers.org/srfi-150</guid><description>SRFI 150 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>	<p>
	  This SRFI provides a specification and portable implementation of an
	  extension of the ERR5RS record syntax
	  of <a href="https://srfi.schemers.org/srfi-131/srfi-131.html">SRFI
	  131</a>, where field names inserted by macro transformers are
	  effectively renamed as if the macro transformer inserted a binding.
	  This makes this SRFI compatible with the semantics of the record-type
	  definitions of
	  the <a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/r7rs.pdf">R7RS</a>
	  as intended by
	  its <a href="https://groups.google.com/d/msg/scheme-reports-wg2/oKuhgwaM45w/KXgPrh8oAwAJ">authors</a>.
	  In addition, field names may also be other types of Scheme datums,
	  like numbers and strings, or
	  <a href="https://srfi.schemers.org/srfi-88/srfi-88.html">SRFI 88</a> keyword objects.</p></*TOP*></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 16 Jan 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 156: Syntactic combiners for binary predicates</title><link>https://srfi.schemers.org/srfi-156/srfi-156.html</link><guid>https://srfi.schemers.org/srfi-156</guid><description>SRFI 156 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>Recognizing binary predicates as a specific area
  in which the use of prefix operators is an impediment,
  we propose a thin layer of "syntactic stevia" for in-fixing
  such predicates. It can be implemented using regular Scheme
  macros. We suggest that the code <code>(is x &lt; y)</code> should
  be transformed to <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code>
  -- to <code>(let ((y* y)) (and (&lt; x y*) (&lt;= y* z)))</code>.
  In addition, we suggest special meaning to the <code>_</code> symbol:
  <code>(is _ &lt; y)</code> and <code>(is x &lt; _)</code>
  should be transformed to <code>(lambda (_) (&lt; _ y))</code>
  and <code>(lambda (_) (&lt; x _))</code>, respectively.
  This SRFI document also describes some other uses of the
  <code>is</code> macro and its limitations.</p></*TOP*></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Mon, 18 Dec 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 158: Generators and Accumulators</title><link>https://srfi.schemers.org/srfi-158/srfi-158.html</link><guid>https://srfi.schemers.org/srfi-158</guid><description>SRFI 158 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*><p>This SRFI defines utility procedures that create, transform, and consume generators.
  A generator is simply a procedure with no arguments that works
  as a source of values.  Every time it is called,
  it yields a value.  Generators may be finite or infinite; a finite
  generator returns an end-of-file object to indicate that it is exhausted.
  For example, <code>read-char</code>, <code>read-line</code>,
  and <code>read</code> are generators that
  generate characters, lines, and objects from the current input port.
  Generators provide lightweight laziness.
</p>

<p>This SRFI also defines procedures that return accumulators.
  An accumulator is the inverse of a generator:  it is a procedure of one argument
  that works as a sink of values.
</p></*TOP*></blockquote></description><dc:creator>Shiro Kawai, John Cowan, and Thomas Gilray</dc:creator><pubDate>Fri, 27 Oct 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 152: String Library (reduced)</title><link>https://srfi.schemers.org/srfi-152/srfi-152.html</link><guid>https://srfi.schemers.org/srfi-152</guid><description>SRFI 152 is now in <em>final</em> status.<h2>Abstract</h2><blockquote><*TOP*>      <p>Scheme has an impoverished set of
      string-processing utilities, which is a problem for authors of portable
      code. This SRFI proposes a coherent and comprehensive set of
      string-processing procedures. It is a reduced version of SRFI 13 that has
      been aligned with SRFI 135, Immutable Texts. Unlike SRFI 13, it has been
      made consistent with the R5RS, R6RS, and R7RS-small string
      procedures.</p></*TOP*></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Wed, 04 Oct 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 40: A Library of Streams</title><link>https://srfi.schemers.org/srfi-40/srfi-40.html</link><guid>https://srfi.schemers.org/srfi-40</guid><description>SRFI 40 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*>      <p>Along with higher-order functions, one of the
      hallmarks of functional programming is lazy evaluation. A primary
      manifestation of lazy evaluation is lazy lists, generally called streams
      by Scheme programmers, where evaluation of a list element is delayed
      until its value is needed.
      </p><p>The literature on lazy evaluation distinguishes
      two styles of laziness, called even and odd. Odd style streams are
      ubiquitous among Scheme programs and can be easily encoded with the
      Scheme primitives delay and force defined in R5RS. However, the even
      style delays evaluation in a manner closer to that of traditional lazy
      languages such as Haskell and avoids an "off by one" error that is
      symptomatic of the odd style.
      </p><p>This SRFI defines the stream data type in the
      even style, some essential procedures and syntax that operate on streams,
      and motivates our choice of the even style. A companion SRFI 41 Stream
      Library provides additional procedures and syntax which make for more
      convenient processing of streams and shows several examples of their
      use.</p></*TOP*></blockquote></description><dc:creator>Philip L. Bewig</dc:creator><pubDate>Thu, 10 Aug 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 114: Comparators</title><link>https://srfi.schemers.org/srfi-114/srfi-114.html</link><guid>https://srfi.schemers.org/srfi-114</guid><description>SRFI 114 is now in <em>withdrawn</em> status.<h2>Abstract</h2><blockquote><*TOP*>      <p>This proposal is a rewrite of 